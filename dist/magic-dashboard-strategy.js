/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/magic-dashboard-strategy.js":
/*!*****************************************!*\
  !*** ./src/magic-dashboard-strategy.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _views_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./views/helpers */ \"./src/views/helpers.js\");\n\n\nfunction mergeHomeAssistantData(areas, devices, entities, states) {\n  function mergeEntityData(entityId, entity, device, state) {\n    const domain = entityId.split(\".\")[0];\n    const mergedEntity = { ...device, domain }; // Start with device info\n\n    // Merge entity properties but skip null values\n    for (const [key, value] of Object.entries(entity)) {\n      if (value !== null) mergedEntity[key] = value;\n    }\n\n    // Merge state properties but skip null values\n    for (const [key, value] of Object.entries(state)) {\n      if (value !== null) mergedEntity[key] = value;\n    }\n\n    return mergedEntity;\n  }\n\n  const mergedData = {};\n\n  // Process entities first\n  for (const [idx, entity] of Object.entries(entities)) {\n    const entityId = entity.entity_id;\n    const device = devices.find((d) => d.id === entity.device_id) || {}; // Get device metadata if available\n    const state = states[entityId] || {}; // Get state info\n\n    mergedData[entityId] = mergeEntityData(entityId, entity, device, state);\n  }\n\n  // Include entities from states that are missing in mergedData\n  // Unsure why but 'zone.home' is missing from entities\n  // Which was populated via hass.callWS({ type: \"config/entity_registry/list\" })\n  for (const [entityId, state] of Object.entries(states)) {\n    if (!mergedData[entityId]) {\n      const device = devices.find((d) => d.id === state.device_id) || {}; // Get device metadata if available\n      mergedData[entityId] = mergeEntityData(entityId, {}, device, state); // Use an empty entity for missing data\n    }\n  }\n\n  // Add in the areas\n  for (const area of areas) {\n    mergedData[`area.${area.area_id}`] = area;\n  }\n\n  return mergedData;\n}\n\nclass Dashboard {\n  static async generate(config, hass) {\n    // Query all data we need. We will make it available to views by storing it in strategy options.\n    const [floors, areas, devices, entities] = await Promise.all([\n      hass.callWS({ type: \"config/floor_registry/list\" }),\n      hass.callWS({ type: \"config/area_registry/list\" }),\n      hass.callWS({ type: \"config/device_registry/list\" }),\n      hass.callWS({ type: \"config/entity_registry/list\" }),\n    ]);\n\n    // TODO: make dense_section_placement a config option\n    // Merge the home assistant data into one object whose keys are the entity ids\n    const mergedEntityMetadata = mergeHomeAssistantData(\n      areas,\n      devices,\n      entities,\n      hass.states\n    );\n\n    // TODO: Remove this debug code\n    console.log(\"floors\");\n    console.log(floors);\n    console.log(\"areas\");\n    console.log(areas);\n    console.log(\"devices\");\n    console.log(devices);\n    console.log(\"entities\");\n    console.log(entities);\n    console.log(\"hass.states\");\n    console.log(hass.states);\n    console.log(\"mergedEntityMetadata\");\n    console.log(mergedEntityMetadata);\n\n    // This temperature view was made really to help me debug some issues with my temperature sensors\n    // I think it can be revised and turned into a \"magic-debugging-dashboard-strategy\" view\n    // Create a view for the temperature\n    const temperature_view = {\n      strategy: {\n        type: \"custom:magic-temperature\",\n        options: {\n          mergedEntityMetadata,\n        },\n      },\n      title: \"Temperature\",\n      path: \"temperature\",\n      icon: \"mdi:thermometer\",\n    };\n\n    // Create a view for the people\n    const people_view = {\n      strategy: {\n        type: \"custom:magic-people\",\n        options: {\n          devices,\n          entities,\n          mergedEntityMetadata,\n        },\n      },\n      title: \"People\",\n      path: \"people\",\n      icon: \"mdi:card-account-details\",\n    };\n\n    // Create a view for each area\n    const area_views = areas\n      .filter((area) => area.icon !== null) // Filter out areas since I have weird areas right now. TODO: remove this filter\n      .sort((a, b) => {\n        // Find the floor object for each area's floor_id\n        const floorA = floors.find((f) => f.floor_id === a.floor_id);\n        const floorB = floors.find((f) => f.floor_id === b.floor_id);\n\n        // Extract levels (default to 0 if not found)\n        const levelA = floorA?.level || 0;\n        const levelB = floorB?.level || 0;\n\n        // First, sort by level (ascending)\n        if (levelA !== levelB) {\n          return levelA - levelB;\n        }\n\n        // If levels are the same, sort alphabetically by name\n        return a.name.localeCompare(b.name);\n      })\n      .map((area) => ({\n        strategy: {\n          type: \"custom:magic-area\",\n          options: {\n            area,\n            devices,\n            entities,\n            mergedEntityMetadata,\n          },\n        },\n        title: area.name,\n        path: area.area_id,\n        icon: area.icon || undefined, // Set the icon if it exists\n      }));\n\n    // Create a view for the weather\n    const weather_entity_id = \"weather.home\";\n    const weather_view = {\n      strategy: {\n        type: \"custom:magic-weather\",\n        options: {\n          devices,\n          entities,\n          weather_entity_id,\n        },\n      },\n      title: \"Weather\",\n      path: \"weather\",\n      icon: getValidWeatherIcon(\n        \"mdi:weather-\" + hass.states[\"weather.home\"].state\n      ),\n    };\n\n    const error_view = {\n      strategy: {\n        type: \"custom:magic-error\",\n      },\n      title: \"Errors\",\n      path: \"errors\",\n      icon: \"mdi:alert-decagram\",\n    };\n\n    const views = [...area_views, people_view, weather_view];\n    if (hass.user.is_admin) {\n      views.push(error_view);\n    }\n    return {\n      views,\n    };\n  }\n}\n\nfunction getValidWeatherIcon(icon) {\n  const validWeatherIcons = new Set([\n    \"mdi:weather-sunny\",\n    \"mdi:weather-cloudy\",\n    \"mdi:weather-rainy\",\n    \"mdi:weather-lightning\",\n    \"mdi:weather-snowy\",\n    \"mdi:weather-fog\",\n    \"mdi:weather-windy\",\n    \"mdi:weather-hail\",\n    \"mdi:weather-partly-cloudy\",\n    \"mdi:weather-sunset\",\n    \"mdi:weather-night\",\n    \"mdi:weather-tornado\",\n    \"mdi:weather-hurricane\",\n    \"mdi:weather-snowy-rainy\",\n    \"mdi:weather-lightning-rainy\",\n    \"mdi:weather-sunny-off\",\n    \"mdi:weather-cloudy-alert\",\n  ]);\n\n  // Check if this is why the dashboard keeps requiring an update\n  return \"mdi:weather-partly-snowy-rainy\";\n  return validWeatherIcons.has(icon) ? icon : \"mdi:weather-sunny\";\n}\n\nclass ErrorView {\n  static async generate(config, hass) {\n    function errorColHeader(name, icon) {\n      return {\n        type: \"custom:bubble-card\",\n        card_type: \"separator\",\n        name,\n        icon,\n        sub_button: [\n          {\n            name: \"Info\",\n            icon: \"mdi:help-circle\",\n            state_background: false,\n            show_background: false,\n            show_attribute: false,\n            show_last_changed: false,\n            tap_action: {\n              action: \"navigate\",\n              navigation_path: `#info-${name}`.toLowerCase(),\n            },\n          },\n          {\n            show_background: false,\n            show_icon: false,\n            show_state: false,\n            name: \" \",\n            show_name: true,\n            tap_action: {\n              action: \"none\",\n            },\n          },\n        ],\n        // rows: 0.75,\n        card_layout: \"large\",\n        modules: _views_helpers__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n        card_mod: _views_helpers__WEBPACK_IMPORTED_MODULE_0__.CARD_MOD,\n      };\n    }\n\n    function dropdown(titleCard, cards) {\n      return {\n        type: \"custom:expander-card\",\n        expanded: true,\n        \"title-card-button-overlay\": true,\n        \"title-card-clickable\": false,\n        clear: true,\n        \"title-card\": titleCard,\n        cards,\n      };\n    }\n\n    return {\n      type: \"sections\",\n      max_columns: 4,\n      badges: [_views_helpers__WEBPACK_IMPORTED_MODULE_0__.alertBadge()],\n      sections: [\n        {\n          type: \"grid\",\n          cards: [\n            dropdown(errorColHeader(\"Errors\", \"mdi:alert-octagram-outline\"), [\n              {\n                type: \"custom:auto-entities\",\n                card: {\n                  type: \"entities\",\n                },\n                filter: {\n                  include: [\n                    {\n                      entity_id: \"*error*\",\n                    },\n                  ],\n                  exclude: [\n                    {\n                      state: \"idle\",\n                    },\n                    {\n                      state: \"off\",\n                    },\n                    {\n                      state: \"none\",\n                    },\n                    {\n                      state: \"ok\",\n                    },\n                  ],\n                },\n              },\n              {\n                type: \"vertical-stack\",\n                cards: [\n                  {\n                    type: \"custom:bubble-card\",\n                    card_type: \"pop-up\",\n                    hash: \"#info-errors\",\n                    name: \"\",\n                    button_type: \"name\",\n                    show_header: false,\n                  },\n                  {\n                    type: \"markdown\",\n                    content:\n                      \"Any entities whose entity id indicates it represents an error. Those which are in a normal state such as `idle`, `off`, or `none` will not be displayed.\",\n                    title: \"Errors\",\n                  },\n                ],\n              },\n            ]),\n          ],\n        },\n        {\n          type: \"grid\",\n          cards: [\n            dropdown(errorColHeader(\"Unknown\", \"mdi:progress-question\"), [\n              {\n                type: \"custom:auto-entities\",\n                card: {\n                  type: \"entities\",\n                },\n                filter: {\n                  include: [\n                    {\n                      state: \"unknown\",\n                    },\n                  ],\n                  exclude: [\n                    {\n                      entity_id: \"^scene\\\\.*\",\n                    },\n                    {\n                      entity_id: \"^button\\\\.*\",\n                    },\n                    {\n                      entity_id: \"^input_button\\\\.*\",\n                    },\n                    {\n                      entity_id: \"^sensor\\\\.discord_user_.*\\\\D.*\",\n                    },\n                    {\n                      integration: \"waze_travel_time\",\n                    },\n                  ],\n                },\n                sort: {\n                  method: \"entity_id\",\n                },\n              },\n              {\n                type: \"vertical-stack\",\n                cards: [\n                  {\n                    type: \"custom:bubble-card\",\n                    card_type: \"pop-up\",\n                    hash: \"#info-unknown\",\n                    name: \"\",\n                    button_type: \"name\",\n                    show_header: false,\n                  },\n                  {\n                    type: \"markdown\",\n                    content:\n                      \"Any entity whose state is currently `unknown`. This excludes some types which are always `unknown` such as `scene`, `button`, and `input_button`. Also excluded are those which are commonly `unknown` and have another entity on the device to indicate an issue, such as sensors included with the `discord_game` integration.\",\n                    title: \"Unknown\",\n                  },\n                ],\n              },\n            ]),\n          ],\n        },\n        {\n          type: \"grid\",\n          cards: [\n            dropdown(errorColHeader(\"Unavailable\", \"mdi:help-circle\"), [\n              {\n                type: \"custom:auto-entities\",\n                card: {\n                  type: \"entities\",\n                },\n                filter: {\n                  include: [\n                    {\n                      state: \"unavailable\",\n                    },\n                  ],\n                  exclude: [],\n                },\n                sort: {\n                  method: \"entity_id\",\n                },\n              },\n              {\n                type: \"vertical-stack\",\n                cards: [\n                  {\n                    type: \"custom:bubble-card\",\n                    card_type: \"pop-up\",\n                    hash: \"#info-unavailable\",\n                    name: \"\",\n                    button_type: \"name\",\n                    show_header: false,\n                  },\n                  {\n                    type: \"markdown\",\n                    content:\n                      \"Any entity whose state is currently `unavailable`. You should review these and determine if they should be deleted or otherwise determine how to start obtaining their state.\",\n                    title: \"Unavailable\",\n                  },\n                ],\n              },\n            ]),\n          ],\n        },\n        {\n          type: \"grid\",\n          cards: [\n            dropdown(errorColHeader(\"Alerts\", \"mdi:alert-outline\"), [\n              {\n                type: \"custom:auto-entities\",\n                card: {\n                  type: \"entities\",\n                },\n                filter: {\n                  include: [\n                    {\n                      entity_id: \"^alert\\\\.*\",\n                    },\n                  ],\n                  exclude: [],\n                },\n                sort: {\n                  method: \"state\",\n                },\n              },\n              {\n                type: \"vertical-stack\",\n                cards: [\n                  {\n                    type: \"custom:bubble-card\",\n                    card_type: \"pop-up\",\n                    hash: \"#info-alerts\",\n                    name: \"\",\n                    button_type: \"name\",\n                    show_header: false,\n                  },\n                  {\n                    type: \"markdown\",\n                    content: \"Any alert entity regardless of status.\",\n                    title: \"Unavailable\",\n                  },\n                ],\n              },\n            ]),\n          ],\n        },\n      ],\n      dense_section_placement: true,\n    };\n  }\n}\n\ncustomElements.define(\"ll-strategy-view-magic-error\", ErrorView);\n\ncustomElements.define(\n  \"ll-strategy-dashboard-magic-dashboard-strategy\",\n  Dashboard\n);\n\n\n//# sourceURL=webpack://magic-dashboard-strategy/./src/magic-dashboard-strategy.js?");

/***/ }),

/***/ "./src/views/area.js":
/*!***************************!*\
  !*** ./src/views/area.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/views/helpers.js\");\n\n\nclass AreaView {\n  static async generate(config, hass) {\n    const { area, devices, entities, mergedEntityMetadata } = config;\n\n    // Extract the entities for this area\n    const thisAreasEntities = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntityByArea(\n      mergedEntityMetadata,\n      area.area_id\n    );\n\n    const max_columns = 4;\n    const sections = [];\n\n    // Get the sensor for magic area state. TODO: do this only once\n    const magic_areas_state_sensor = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(thisAreasEntities, {\n        domain: \"binary_sensor\",\n        platform: \"magic_areas\",\n        \"attributes.device_class\": \"occupancy\",\n      })\n      .filter((entity) => entity.attributes && entity.attributes.type)[0]; // Filter to just the \"magic area state\" entity as to remove others such as the \"aggregate_occupancy\" sensor but don't rely on entity id\n\n    // Add the header grid\n    sections.push(\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(\n        [\n          newViewHeader(hass, devices, entities, area, thisAreasEntities),\n          AreaStatePopUp(area, magic_areas_state_sensor),\n        ],\n        max_columns\n      )\n    );\n\n    // Add the light grid\n    sections.push(lightGrid(area, thisAreasEntities));\n\n    // Add the fan grid\n    sections.push(fanGrid(area, mergedEntityMetadata));\n\n    // Add the litterbot grid\n    sections.push(_helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(litterbotCards(thisAreasEntities)));\n\n    // Add the vacuum grid\n    sections.push(_helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(vacuumCards(thisAreasEntities)));\n\n    // Temperature Graph Grid\n    // sections.push(\n    //   helpers.newGrid(newAreaTemperatureGraph(area, thisAreasEntities))\n    // );\n    sections.push(climate_control_grid(mergedEntityMetadata, area));\n\n    // Automations Grid\n    sections.push(AutomationGrid(thisAreasEntities));\n\n    // Scripts Grid\n    sections.push(ScriptGrid(thisAreasEntities));\n\n    // Add card mod\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.AddCardMod(sections);\n\n    return {\n      type: \"sections\",\n      title: area.name,\n      max_columns: max_columns,\n      badges: [_helpers_js__WEBPACK_IMPORTED_MODULE_0__.alertBadge()],\n      sections: sections.filter((section) => section !== null),\n    };\n  }\n}\n\nfunction fanGrid(area, mergedEntityMetadata) {\n  function newFanBubble(entity) {\n    function calculateColumns(nameLength) {\n      // Base value\n      let columns = 1.2;\n\n      // Increase by 0.2 for every additional 3 characters\n      columns += Math.floor(nameLength / 3) * 0.2;\n\n      // Ensure it doesn't exceed the max of 4\n      return Math.min(columns, 4);\n    }\n\n    return {\n      type: \"custom:bubble-card\",\n      card_type: \"button\",\n      entity: entity.entity_id,\n      icon: \"mdi:fan\",\n      // styles:\n      //   \"\\n.bubble-icon {\\n ${ state === 'on' ? 'animation: rotate 1.5s linear infinite !important;' : '' }  \\n}\\n@keyframes rotate {\\n  0% { transform: rotate(0deg); }\\n  100% { transform: rotate(360deg); }\\n}\",\n      card_layout: \"large\",\n      columns: calculateColumns(entity.name.length),\n      tap_action: {\n        action: \"toggle\",\n      },\n      double_tap_action: {\n        action: \"more-info\",\n      },\n      hold_action: {\n        action: \"more-info\",\n      },\n      modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n    };\n  }\n\n  // Cards array\n  const cards = [];\n\n  // Get all the fans for this area\n  const fans = Object.values(\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntityKeysByDomain(mergedEntityMetadata, \"fan\")\n  ).filter((x) => x.area_id === area.area_id);\n\n  // If we don't have fans then return null\n  if (fans.length === 0) {\n    return null;\n  }\n\n  // Add the header\n  const headerStyles = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n      const state = hass.states['${fans[0].entity_id}'].state;\n      const entity_ids = [${fans.map((x) => `\"${x.entity_id}\"`).join(\", \")}];\n      const allSame = entity_ids.every(entity_id => hass.states[entity_id].state === state);\n\n      if (allSame) {\n        icon.setAttribute('icon', 'mdi:fan')\n        icon.setAttribute('data-state', state)\n      } else { icon.removeAttribute('data-state')}\n  `);\n  cards.push(sectionHeader(\"mdi:fan\", \"Fans\", headerStyles));\n\n  // Add the fans to the cards array\n  cards.push(...fans.map((fan) => newFanBubble(fan)));\n\n  // Return the grid of fans\n  return _helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(cards);\n}\n\nfunction lightGrid(area, thisAreasEntities) {\n  const cards = [];\n\n  // Add the lights\n  cards.push(...newLights(thisAreasEntities));\n\n  // Return null if we have no lights\n  if (cards.length === 0) {\n    return null;\n  }\n\n  // Add adaptive lighting controls\n  // cards.push(newAdaptiveControls(area));\n  cards.push(newAdaptiveControlsIconsOnly(area, thisAreasEntities));\n  const motionControls = newMotionControlsIconsOnly(area, thisAreasEntities);\n  if (motionControls) {\n    cards.push(spacer(1.25), motionControls);\n  }\n\n  // Add the header\n  cards.unshift(sectionHeader(\"mdi:lightbulb\", \"Lights\"));\n\n  // Return the grid\n  return _helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(cards);\n}\n\nfunction newViewHeader(hass, devices, entities, area, thisAreasEntities) {\n  let defaultIcon = \"mdi:information\";\n  let subButtons = [];\n\n  // Add vacuum icon if its in the room\n  const vacuum_entity = \"sensor.rosey_the_robot_current_room\"; // TODO: dont hard code\n  subButtons.push({\n    entity: vacuum_entity,\n    icon: \"mdi:robot-vacuum\",\n    name: \"Robot Vacuum\",\n    visibility: [\n      {\n        condition: \"state\",\n        entity: vacuum_entity,\n        state: area.name,\n      },\n    ],\n  });\n\n  // // Add Temperature\n  // subButtons.push({\n  //   entity: `sensor.area_${area.area_id}_temperature`,\n  //   show_attribute: false,\n  //   show_icon: false,\n  //   light_background: true,\n  //   state_background: false,\n  //   show_background: false,\n  //   show_state: true,\n  //   show_last_changed: false,\n  //   name: \"Temperature\",\n  // });\n\n  const magic_area_temperature = `sensor.magic_areas_aggregates_${area.area_id}_aggregate_temperature`;\n\n  // // Add all the magic stuff\n  // const magic_entities = helpers\n  //   .filterEntitiesToMagicArea(devices, entities, area.area_id)\n  //   .filter((entity) => entity.entity_id !== magic_area_temperature);\n  // magic_entities.forEach((entity) => {\n  //   let friendly_name = entity.name;\n  //   if (!friendly_name) {\n  //     friendly_name = entity.original_name;\n  //   }\n  //   if (friendly_name) {\n  //     friendly_name = friendly_name.replace(area.name, \"\").trim();\n  //   }\n\n  //   subButtons.push({\n  //     entity: entity.entity_id,\n  //     show_attribute: false,\n  //     show_icon: true,\n  //     light_background: true,\n  //     state_background: false,\n  //     show_background: false,\n  //     show_state: true,\n  //     show_last_changed: false,\n  //     name: friendly_name,\n  //     show_name: true,\n  //   });\n  // });\n\n  // Add Magic Area Temperature\n  // if (helpers.entityExists(hass, magic_area_temperature)) {\n  //   subButtons.push({\n  //     entity: magic_area_temperature,\n  //     show_attribute: false,\n  //     show_icon: false,\n  //     light_background: true,\n  //     state_background: false,\n  //     show_background: false,\n  //     show_state: true,\n  //     show_last_changed: false,\n  //     name: \"Temperature\",\n  //   });\n  // }\n\n  // // Add motion sensor\n  // subButtons.push({\n  //   entity: `binary_sensor.${area.area_id}_motion`,\n  //   name: \"Motion\",\n  //   state_background: false,\n  //   show_background: false,\n  // });\n\n  // // Add magic motion sensor\n  // subButtons.push({\n  //   entity: `binary_sensor.magic_areas_aggregates_${area.area_id}_aggregate_motion`,\n  //   name: \"Motion\",\n  //   state_background: false,\n  //   show_background: false,\n  // });\n\n  // Add magic state sensor\n  const magic_areas_state_sensor = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(thisAreasEntities, {\n      domain: \"binary_sensor\",\n      platform: \"magic_areas\",\n      \"attributes.device_class\": \"occupancy\",\n    })\n    .filter((entity) => entity.attributes && entity.attributes.type)[0]; // Filter to just the \"magic area state\" entity as to remove others such as the \"aggregate_occupancy\" sensor but don't rely on entity id\n\n  if (magic_areas_state_sensor) {\n    subButtons.push({\n      entity: magic_areas_state_sensor.entity_id,\n      name: \"Magic Areas State\",\n      state_background: false,\n      show_background: false,\n      show_icon: false,\n      show_state: true,\n      tap_action: {\n        action: \"navigate\",\n        navigation_path: \"#occupancy\",\n      },\n    });\n  }\n\n  // Add a link to the main area config\n  if (true) {\n    subButtons.push({\n      name: \"Area Link\",\n      icon: \"mdi:information\",\n      state_background: false,\n      show_background: false,\n      tap_action: {\n        action: \"navigate\",\n        navigation_path: `/config/areas/area/${area.area_id}`,\n      },\n    });\n  }\n\n  // // Add magic state sensor states\n  // subButtons.push({\n  //   entity: `binary_sensor.magic_areas_presence_tracking_${area.area_id}_area_state`,\n  //   name: \"Magic Areas States\",\n  //   state_background: false,\n  //   show_background: false,\n  //   show_icon: false,\n  //   show_state: false,\n  //   show_attribute: true,\n  //   attribute: \"states\",\n  // });\n\n  const funcs = `\n      function titleCaseCSV(csvString) {\n      // Function to convert a string to Title Case\n      function toTitleCase(str) {\n        return str\n          .toLowerCase()\n          .split(\" \")\n          .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n          .join(\" \");\n      }\n\n      // Split CSV string into individual elements\n      let elements = csvString.split(\",\");\n\n      // Apply title case transformation\n      let transformedElements = elements.map(item => toTitleCase(item.trim()));\n\n      // Join elements with • instead of commas\n      return transformedElements.join(\" • \");\n    }\n  `;\n\n  const styles = `\n    \\${(() => {\n\n      ${funcs}\n\n      let container = card.querySelector('.bubble-sub-button-2 .bubble-sub-button-name-container')\n      container.innerText = titleCaseCSV(container.innerText)\n\n    })()}\n    `;\n\n  return {\n    type: \"custom:bubble-card\",\n    card_layout: \"large\",\n    card_type: \"separator\",\n    name: area.name,\n    icon: area.icon || defaultIcon,\n    sub_button: subButtons,\n    // styles: styles,\n    grid_options: {\n      columns: \"full\",\n    },\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n  };\n}\n\nfunction newLightBubble(entity_id, adaptive_entity, show_name) {\n  console.log(entity_id);\n  console.log(adaptive_entity);\n  let styles = undefined;\n  let subbutton1 = undefined;\n  if (adaptive_entity !== undefined) {\n    styles = `\n      .bubble-sub-button-1 {\n        display: \\${hass.states['${adaptive_entity.entity_id}'].attributes.autoreset_time_remaining && Object.keys(hass.states['${adaptive_entity.entity_id}'].attributes.autoreset_time_remaining).length === 0 ? 'none' : ''} !important;\n      }\n      \\${(() => {\n\n        function addSecondsToNow(seconds) {\n            seconds = Math.round(seconds)\n            let currentDate = new Date();               // Get the current date and time\n            currentDate.setSeconds(currentDate.getSeconds() + seconds);  // Add the seconds to the current time\n            return currentDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});\n        }\n\n        function formatTime(seconds) {\n            seconds = Math.round(seconds)\n            let hrs = Math.floor(seconds / 3600);\n            let mins = Math.floor((seconds % 3600) / 60);\n            let secs = seconds % 60;\n\n            // Build the time string and remove leading zeros for hours, minutes, and seconds\n            let timeString = [];\n            if (hrs > 0) timeString.push(hrs);\n            if (mins > 0 || hrs > 0) timeString.push(mins.toString().padStart(2, '0'));\n            timeString.push(secs.toString().padStart(2, '0'));\n\n            return timeString.join(':');\n        }\n\n        function replaceTextInBraces(str, replacement) {\n            return str.replace(/{[^}]*}/g, replacement);\n        }\n\n\n        let subButton = card.querySelector('.bubble-sub-button-1 .bubble-sub-button-name-container');\n        if (subButton) {\n          let text = subButton.innerText.trim();\n          text = text.substring(0, text.length - 1);\n          let keyValue = text.split(':');\n          if (keyValue.length > 1) {\n            subButton.innerText = replaceTextInBraces(subButton.innerText, addSecondsToNow(keyValue[1]));\n          }\n        }\n      })()}\n      `;\n    // + helpers.wrapInBubbleCardStyleIIFE(\n    //   `if (card.classList.contains('is-on')) {icon.classList.add('breathing-glow')} else {icon.classList.remove('breathing-glow')}`\n    // )\n    subbutton1 = {\n      show_attribute: true,\n      show_last_changed: false,\n      show_state: false,\n      show_name: true,\n      show_icon: false,\n      attribute: \"autoreset_time_remaining\",\n      state_background: false,\n      show_background: false,\n      name: \"Manual Override\", // Todo: translation\n      entity: adaptive_entity.entity_id,\n      tap_action: {\n        action: \"perform-action\",\n        perform_action: \"adaptive_lighting.set_manual_control\",\n        target: {},\n        data: {\n          manual_control: false,\n          entity_id: adaptive_entity.entity_id,\n        },\n      },\n      double_tap_action: {\n        action: \"none\",\n      },\n      hold_action: {\n        action: \"none\",\n      },\n    };\n  }\n\n  const subButton2 = {\n    name: \"Menu\",\n    show_background: false,\n    icon: \"mdi:menu\",\n  };\n\n  return {\n    type: \"custom:bubble-card\",\n    card_layout: \"large\",\n    card_type: \"button\",\n    button_type: \"slider\",\n    entity: entity_id,\n    scrolling_effect: false,\n    show_icon: true,\n    force_icon: false,\n    slider_live_update: false,\n    sub_button: [subbutton1, subButton2],\n    show_attribute: true,\n    attribute: \"brightness\",\n    styles: \"\",\n    show_state: false,\n    show_name,\n    tap_action: {\n      action: \"toggle\",\n    },\n    double_tap_action: {\n      action: \"more-info\",\n    },\n    hold_action: {\n      action: \"more-info\",\n    },\n    styles,\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n  };\n}\n\nfunction newLights(thisAreasEntities) {\n  const adaptive_entity = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(thisAreasEntities, {\n      platform: \"adaptive_lighting\",\n      domain: \"switch\",\n    })\n    .filter((entity) => {\n      return entity.original_name.startsWith(\"Adaptive Lighting:\");\n    })[0]; // Todo: Check if this is language agnostic or if there is just a better way than using \"original_name\"\n\n  const lights = thisAreasEntities.filter((item) => item.domain === \"light\");\n\n  console.log(adaptive_entity);\n  const cards = lights.map((light) => {\n    return newLightBubble(light.entity_id, adaptive_entity, lights.length > 1);\n  });\n  return cards;\n}\n\nfunction newMotionControlsIconsOnly(area, thisAreasEntities) {\n  // Todo: don't rely on entity id naming scheme\n  // const motionActivated = `input_boolean.motion_lights_${area.area_id}`;\n  // const motionActivated = `automation.magic_areas_light_${area.area_id}`;\n  const presenceHold = `switch.magic_areas_presence_hold_${area.area_id}`;\n\n  const motionActivated = thisAreasEntities.find(\n    (x) =>\n      x.domain === \"switch\" &&\n      x.identifiers?.[0]?.[0] === \"magic_areas\" &&\n      x.original_name == \"Light Control\" // TODO: Find a better way to do this as it might change but without this it will get the presence hold instead\n  )?.entity_id;\n\n  function subbutton(\n    entityID,\n    mainAdaptiveEntityId = undefined,\n    dictToMerge = {}\n  ) {\n    let visibility = [];\n    if (mainAdaptiveEntityId !== undefined) {\n      visibility.push({\n        condition: \"state\",\n        entity: mainAdaptiveEntityId,\n        state: \"on\",\n      });\n    }\n\n    let button = {\n      name: entityID,\n      entity: entityID,\n      tap_action: {\n        action: \"toggle\",\n      },\n      visibility: visibility,\n      hold_action: {\n        action: \"more-info\",\n      },\n    };\n\n    return { ...button, ...dictToMerge };\n  }\n\n  // Add the sub buttons\n  let styles = \"\";\n  const sub_buttons = [];\n  const valid_entity_ids = thisAreasEntities.map((entity) => entity.entity_id);\n  let presenceHoldVisibility = {};\n  if (valid_entity_ids.includes(motionActivated)) {\n    sub_buttons.push(subbutton(motionActivated));\n    styles = `\\${subButtonIcon[0].setAttribute(\"icon\", hass.states['${motionActivated}'].state === 'on' ? 'mdi:motion-sensor' : 'mdi:motion-sensor-off')}`;\n\n    presenceHoldVisibility = {\n      visibility: {\n        condition: \"or\",\n        conditions: [\n          {\n            condition: \"state\",\n            entity: motionActivated,\n            state: \"on\",\n          },\n          {\n            condition: \"state\",\n            entity: presenceHold,\n            state: \"on\",\n          },\n        ],\n      },\n    };\n  }\n  if (valid_entity_ids.includes(presenceHold)) {\n    sub_buttons.push(\n      subbutton(presenceHold, undefined, presenceHoldVisibility)\n    );\n  }\n\n  // Return null if we have no sub buttons because this card is just sub buttons\n  if (sub_buttons.length === 0) {\n    return null;\n  }\n\n  return newBubbleIconButtons(sub_buttons, styles);\n}\n\nfunction spacer(columns) {\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"empty-column\",\n    columns,\n  };\n}\n\nfunction newAdaptiveControlsIconsOnly(area, thisAreasEntities) {\n  // Todo: don't rely on entity id naming scheme\n  const adaptive = `switch.adaptive_lighting_${area.area_id}`;\n  const autoBrightness = `switch.adaptive_lighting_adapt_brightness_${area.area_id}`;\n  const autoColor = `switch.adaptive_lighting_adapt_color_${area.area_id}`;\n  const sleepMode = `switch.adaptive_lighting_sleep_mode_${area.area_id}`;\n\n  function subbutton(entityID, mainAdaptiveEntityId) {\n    let visibility = [];\n    if (mainAdaptiveEntityId !== undefined) {\n      visibility.push({\n        condition: \"state\",\n        entity: mainAdaptiveEntityId,\n        state: \"on\",\n      });\n    }\n\n    let button = {\n      name: entityID,\n      entity: entityID,\n      tap_action: {\n        action: \"toggle\",\n      },\n      visibility: visibility,\n      hold_action: {\n        action: \"more-info\",\n      },\n    };\n\n    return button;\n  }\n\n  // Add the sub buttons\n  const sub_buttons = [];\n  const valid_entity_ids = thisAreasEntities.map((entity) => entity.entity_id);\n  if (valid_entity_ids.includes(adaptive)) {\n    sub_buttons.push(subbutton(adaptive));\n\n    if (valid_entity_ids.includes(autoBrightness)) {\n      sub_buttons.push(subbutton(autoBrightness, adaptive));\n    }\n    if (valid_entity_ids.includes(autoColor)) {\n      sub_buttons.push(subbutton(autoColor, adaptive));\n    }\n    if (valid_entity_ids.includes(sleepMode)) {\n      sub_buttons.push(subbutton(sleepMode, adaptive));\n    }\n\n    sub_buttons.push({\n      name: \"Apply Now\",\n      icon: \"mdi:auto-fix\",\n      show_name: false,\n      show_last_changed: false,\n      show_attribute: false,\n      tap_action: {\n        action: \"perform-action\",\n        perform_action: \"adaptive_lighting.apply\",\n        target: {},\n        data: {\n          entity_id: adaptive,\n        },\n      },\n    });\n  }\n\n  // Return null if we have no sub buttons because this card is just sub buttons\n  if (sub_buttons.length === 0) {\n    return null;\n  }\n\n  return newBubbleIconButtons(sub_buttons, undefined, 4);\n}\n\nfunction newBubbleIconButtons(\n  sub_buttons,\n  styles = \"\",\n  column_override = undefined\n) {\n  //TODO: there has to be a pure CSS way instead of setting justify and margin programmatically\n  const icon_px = 46;\n  // const min_columns = 3; // any less than 3 even with 1 sub button gets cut off on mobile. This is for grid options columns not bubble card columns\n  const min_columns = 0; //\n  const button_to_column_multiplier = 0.7; // TODO: make based of the icon sizes\n  const justify_content =\n    sub_buttons.length < 3 ? \"space-evenly\" : \"space-between\";\n  const margin_right = sub_buttons.length === 2 ? \"-3%\" : \"0px\";\n\n  const columns =\n    column_override !== undefined\n      ? column_override\n      : Math.max(min_columns, sub_buttons.length * button_to_column_multiplier);\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    card_layout: \"large\",\n    button_type: \"name\",\n    show_icon: false,\n    show_name: false,\n    sub_button: sub_buttons,\n    styles: `.card-content {\\n  width: 100%;\\n  margin: 0 !important;\\n}\\n\\n.bubble-sub-button {\\n  height: ${icon_px}px !important;\\n  width: ${icon_px}px !important;\\n}\\n.bubble-sub-button-container {\\n  display: flex !important; width: 100%;\\n  justify-content: ${justify_content} !important;\\n}\\n.bubble-sub-button-icon {\\n  --mdc-icon-size: inherit !important;\\n}\\n.bubble-name-container {\\n  margin-right: ${margin_right} !important;\\n}\\n${styles}`,\n    columns,\n  };\n}\n\n// function newAdaptiveControls(area) {\n//   function newStyle(entityId) {\n//     const onColor = \"var(--bubble-accent-color, var(--accent-color))\";\n//     const offColor = \"var(--disabled-color)\";\n\n//     return `\\${hass.states['${entityId}'].state === 'on' ?  '${onColor}'  : '${offColor}'} !important;`;\n//   }\n\n//   const adaptive = `switch.adaptive_lighting_${area.area_id}`;\n//   const autoBrightness = `switch.adaptive_lighting_adapt_brightness_${area.area_id}`;\n//   const autoColor = `switch.adaptive_lighting_adapt_color_${area.area_id}`;\n//   const sleepMode = `switch.adaptive_lighting_sleep_mode_${area.area_id}`;\n//   // const motionActivated = `switch.motion_lights_${area.area_id}`;\n//   const motionActivated = `switch.magic_areas_presence_hold_${area.area_id}`;\n\n//   let styles = \".bubble-button-background {\\n  opacity: 0 !important;\\n}\\n\";\n//   styles += `.bubble-sub-button-1 {\\n  color: ${newStyle(autoBrightness)}\\n}`;\n//   styles += `.bubble-sub-button-2 {\\n  color: ${newStyle(autoColor)}\\n}`;\n//   styles += `.bubble-sub-button-3 {\\n  color: ${newStyle(sleepMode)}\\n}`;\n//   styles += `.bubble-sub-button-4 {\\n  color: ${newStyle(motionActivated)}\\n}`;\n\n//   return {\n//     type: \"custom:bubble-card\",\n//     card_type: \"button\",\n//     entity: adaptive,\n//     grid_options: {\n//       rows: 1,\n//       columns: \"full\",\n//     },\n//     show_name: true,\n//     show_icon: true,\n//     scrolling_effect: true,\n//     show_attribute: false,\n//     name: \"Smart Lights\",\n//     sub_button: [\n//       {\n//         entity: autoBrightness,\n//         state_background: true,\n//         show_name: true,\n//         name: \"Brightness\",\n//         show_background: false,\n//         show_icon: true,\n//         show_state: false,\n//         tap_action: {\n//           action: \"toggle\",\n//         },\n//         visibility: [\n//           {\n//             condition: \"state\",\n//             entity: adaptive,\n//             state: \"on\",\n//           },\n//         ],\n//       },\n//       {\n//         entity: autoColor,\n//         show_icon: true,\n//         state_background: false,\n//         show_state: false,\n//         show_name: true,\n//         name: \"Color\",\n//         tap_action: {\n//           action: \"toggle\",\n//         },\n//         visibility: [\n//           {\n//             condition: \"state\",\n//             entity: adaptive,\n//             state: \"on\",\n//           },\n//         ],\n//         show_background: false,\n//       },\n//       {\n//         entity: sleepMode,\n//         name: \"Sleep Mode\",\n//         show_name: true,\n//         show_attribute: false,\n//         show_last_changed: false,\n//         state_background: true,\n//         show_background: false,\n//         show_state: false,\n//         visibility: [\n//           {\n//             condition: \"state\",\n//             entity: adaptive,\n//             state: \"on\",\n//           },\n//         ],\n//         tap_action: {\n//           action: \"toggle\",\n//         },\n//       },\n//       {\n//         entity: motionActivated,\n//         state_background: true,\n//         show_name: true,\n//         name: \"Motion\",\n//         show_background: false,\n//         show_icon: true,\n//         show_state: false,\n//         tap_action: {\n//           action: \"toggle\",\n//         },\n//       },\n//     ],\n//     show_state: true,\n//     card_layout: \"large-2-rows\",\n//     force_icon: false,\n//     show_last_changed: false,\n//     tap_action: {\n//       action: \"toggle\",\n//     },\n//     styles: styles,\n//   };\n// }\n\nfunction newAreaTemperatureGraph(area, thisAreasEntities) {\n  // Todo: remove hard coding and don't rely on entity id naming scheme\n  const room = `sensor.magic_areas_aggregates_${area.area_id}_aggregate_temperature`;\n  const home = \"sensor.magic_areas_aggregates_interior_aggregate_temperature\";\n  const outdoor = \"sensor.outdoor_temperature\";\n\n  // Return null if we don't have a room temperature as the whole point is to show the temperature of this room\n  const valid_entity_ids = thisAreasEntities.map((entity) => entity.entity_id);\n  if (!valid_entity_ids.includes(room)) {\n    return null;\n  }\n\n  return [\n    {\n      type: \"custom:mini-graph-card\",\n      entities: [\n        {\n          entity: room,\n          name: area.name,\n          show_state: true,\n        },\n        {\n          entity: home,\n          name: \"Indoor\",\n          show_state: true,\n          show_fill: false,\n        },\n        // {\n        //   entity: outdoor,\n        //   name: \"Outdoor\",\n        //   y_axis: \"secondary\",\n        //   show_state: true,\n        //   show_fill: false,\n        // },\n      ],\n      hours_to_show: 24,\n      animate: true,\n      color_thresholds: [\n        {\n          value: 65,\n          color: \"aqua\",\n        },\n        {\n          value: 68,\n          color: \"#00ff00\",\n        },\n        {\n          value: 72,\n          color: \"orange\",\n        },\n        {\n          value: 76,\n          color: \"red\",\n        },\n      ],\n      show: {\n        icon: false,\n        name: false,\n        extrema: true,\n        average: true,\n        fill: \"fade\",\n      },\n      decimals: 0,\n      points_per_hour: 1,\n    },\n  ];\n}\n\n/**\n * @returns {array} - Array of litterbot cards or null if no litterbot are found\n */\nfunction litterbotCards(entities) {\n  const cards = [];\n\n  // Get all the proper vacuum entities\n  const litterrobots = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(entities, {\n    platform: \"litterrobot\",\n    domain: \"vacuum\",\n  });\n\n  // Iterate over each litter robot and generate a card for it\n  litterrobots.forEach((litterrobot) => {\n    const related_entities = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(entities, {\n      device_id: litterrobot.device_id,\n    });\n\n    // TODO: make this not based on entity_id since that can be changed by the user\n    const litter_level = related_entities.filter((e) =>\n      e.entity_id.endsWith(\"_litter_level\")\n    )[0];\n    const waste_drawer = related_entities.filter((e) =>\n      e.entity_id.endsWith(\"_waste_drawer\")\n    )[0];\n    const status_code = related_entities.filter((e) =>\n      e.entity_id.endsWith(\"_status_code\")\n    )[0];\n    const pet_weight = related_entities.filter((e) =>\n      e.entity_id.endsWith(\"_pet_weight\")\n    )[0];\n\n    // Update the icon to have a cat in it if its in Cat Sensor Timing\n    let styles = `\\${icon.setAttribute(\"icon\", ['cst', 'cd'].includes(hass.states['${status_code.entity_id}'].state) ? 'phu:litter-robot' : 'phu:litter-robot-empty')}`; // TODO: fall back to mdi icons if window.customIcons.phu does not exist. Or better yet, find a WebSocket call or something to check for installed HACs resources but if we go that way, ensure manual installs still work\n\n    // Make it glow when there is an error\n    styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n      if (hass.states['${litterrobot.entity_id}'].state === 'error') {\n        card.style.setProperty('--glow-color', 'var(--error-color)');\n        card.classList.add('breathing-glow-alt')\n      } else {\n        card.style.removeProperty('--glow-color');\n        card.classList.remove('breathing-glow-alt')\n      }\n\n      const nearly_full = 75;\n      const nearly_empty = 60;\n\n      const litter_button = card.querySelector('.bubble-sub-button-1');\n      if (hass.states['${litter_level.entity_id}'].state <= nearly_full) {\n        litter_button.style.setProperty('--glow-color', 'var(--warning-color)');\n        litter_button.classList.add('breathing-glow-alt')\n      } else if (hass.states['${litter_level.entity_id}'].state <= nearly_empty) {\n        litter_button.style.setProperty('--glow-color', 'var(--error-color)');\n        litter_button.classList.add('breathing-glow-alt')\n      } else {\n        litter_button.style.removeProperty('--glow-color');\n        litter_button.classList.remove('breathing-glow-alt')\n      }\n\n      const waste_button = card.querySelector('.bubble-sub-button-2');\n      if (hass.states['${waste_drawer.entity_id}'].state >= nearly_full) {\n        waste_button.style.setProperty('--glow-color', 'var(--warning-color)');\n        waste_button.classList.add('breathing-glow-alt')\n      } else if (hass.states['${litter_level.entity_id}'].state <= nearly_empty) {\n        waste_button.style.setProperty('--glow-color', 'var(--error-color)');\n        waste_button.classList.add('breathing-glow-alt')\n      } else {\n        waste_button.style.removeProperty('--glow-color');\n        waste_button.classList.remove('breathing-glow-alt')\n      }\n    `);\n    styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.bubbleCSSImport();\n\n    // Make the name subtext field where an attribute usually is instead have the current status code\n    const styles_iife = `const bubbleNameContainer = card.querySelector('.bubble-state.state.display-state .scrolling-container');if (bubbleNameContainer) { bubbleNameContainer.innerText = hass.formatEntityState(hass.states['${status_code.entity_id}']);}\\n`;\n    // styles = `const bubbleNameContainer = card.querySelector('.bubble-state.state.display-state .scrolling-container');if (bubbleNameContainer) { bubbleNameContainer.innerHTML = bubbleNameContainer.innerHTML.replace(/${litterrobot.attributes.friendly_name}/g, hass.formatEntityState(hass.states['${status_code.entity_id}']) );}`\n    // styles = `const bubbleNameContainer = card.querySelector('.bubble-state.state.display-state .scrolling-container');if (bubbleNameContainer) { bubbleNameContainer.innerHTML = bubbleNameContainer.innerHTML.replace(/hass.states['${litterrobot.entity_id}'].attributes.friendly_name}/g, hass.formatEntityState(hass.states['${status_code.entity_id}']) );}`\n\n    // styles = helpers.wrapInBubbleCardStyleIIFE(styles)\n    // styles = styles + \"\\n\" + helpers.wrapInBubbleCardStyleIIFE(styles_iife);\n\n    // Create some default options to be shared across the subbuttons\n    const subbutton_options = {\n      show_name: true,\n      show_attribute: false,\n      show_icon: true,\n      state_background: false,\n      show_background: false,\n      show_state: true,\n    };\n    const subbutton_spacer = {\n      name: \" \",\n      show_name: false,\n      show_attribute: false,\n      show_icon: false,\n      state_background: false,\n      show_background: false,\n      show_state: false,\n    };\n\n    const weight_button = {\n      ...subbutton_options,\n      ...{\n        name: \"Weight\",\n        entity: pet_weight.entity_id,\n        show_name: false,\n        show_icon: true,\n        icon: \"mdi:cat\",\n      },\n    };\n\n    // TODO: only add entities we actually find instead of assuming we found them\n    cards.push({\n      type: \"custom:bubble-card\",\n      card_type: \"button\",\n      button_type: \"state\",\n      entity: litterrobot.entity_id,\n      sub_button: [\n        {\n          entity: litter_level.entity_id,\n          show_name: true,\n          name: \"Litter\",\n          show_attribute: false,\n          show_icon: true,\n          state_background: false,\n          show_background: false,\n          show_state: true,\n        },\n        {\n          entity: waste_drawer.entity_id,\n          name: \"Waste\",\n          show_name: true,\n          state_background: false,\n          show_background: false,\n          show_state: true,\n        },\n        // weight_button, // TODO: find a way to display weight data without covering up the status\n        // {\n        //   entity: status_code.entity_id,\n        //   show_name: false,\n        //   show_last_changed: false,\n        //   name: \"Status\",\n        //   show_state: true,\n        //   state_background: false,\n        //   show_background: false,\n        //   show_attribute: false,\n        //   attribute: \"options\",\n        //   show_icon: false,\n        //   visibility: [\n        //     {\n        //       condition: \"state\",\n        //       entity: status_code.entity_id,\n        //       state_not: \"rdy\",\n        //     },\n        //   ],\n        // },\n      ],\n      card_layout: \"large-2-rows\",\n      show_state: false,\n      show_attribute: true,\n      attribute: \"friendly_name\",\n      show_last_changed: false, // Setting to true will cause the status_code replacement to flicker\n      columns: 4, // TODO: change to 3 but enable a text scrolling safe replacement for the status\n      styles,\n      modules: [..._helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES, \"get_state_attribute\"],\n      get_state_attribute: [\n        {\n          entity: status_code.entity_id,\n        },\n        {},\n        {},\n        {},\n      ],\n    });\n  });\n\n  // Return null if we have no cards\n  if (cards.length === 0) {\n    return null;\n  }\n\n  // Add the header\n  // TODO: Auto detect if this should be \"Cats\", \"Dogs\", or \"Pets\"\n  cards.unshift(sectionHeader(\"mdi:cat\", \"Cats\"));\n\n  // Return the cards\n  return cards;\n}\n\nfunction vacuumCards(entities) {\n  const cards = [];\n\n  // Get all the proper vacuum entities\n  const banned_platforms = [\"litterrobot\"];\n  const vacuums = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(entities, { domain: \"vacuum\" })\n    .filter((entity) => !banned_platforms.includes(entity.platform));\n\n  // Iterate over each vacuum and create a card for it\n  vacuums.forEach((vacuum) => {\n    const related_entities = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(entities, {\n      device_id: vacuum.device_id,\n    });\n\n    console.log(related_entities);\n\n    const visibility_is_moving = {\n      condition: \"or\",\n      conditions: [\n        {\n          condition: \"state\",\n          entity: vacuum.entity_id,\n          state: \"returning\",\n        },\n        {\n          condition: \"state\",\n          entity: vacuum.entity_id,\n          state: \"cleaning\",\n        },\n      ],\n    };\n\n    const battery_entity = related_entities.filter(\n      (e) => e.attributes?.device_class === \"battery\"\n    )[0];\n\n    const status_code = related_entities.filter(\n      (e) => e.translation_key === \"status\" // TODO: Check other vacuum integrations and ensure this works for more than just roborock\n    )[0];\n\n    const error_sensors = related_entities.filter(\n      (e) => e.entity_id.endsWith(\"_error\") // TODO: Check other vacuum integrations and ensure this works for more than just roborock\n    );\n\n    const error_buttons = error_sensors.map((e) => ({\n      entity: e.entity_id,\n      show_attribute: false,\n      show_state: true,\n      show_name: false,\n      name: e.attributes.friendly_name,\n      show_icon: false,\n      state_background: false,\n      show_background: false,\n      visibility: [\n        {\n          condition: \"and\",\n          conditions: [\n            {\n              condition: \"state\",\n              entity: e.entity_id,\n              state_not: \"none\",\n            },\n            {\n              condition: \"state\",\n              entity: e.entity_id,\n              state_not: \"ok\",\n            },\n            {\n              condition: \"state\",\n              entity: e.entity_id,\n              state_not: \"idle\",\n            },\n            {\n              condition: \"state\",\n              entity: e.entity_id,\n              state_not: \"off\",\n            },\n          ],\n        },\n      ],\n    }));\n\n    const battery_button = {\n      entity: battery_entity.entity_id, // TODO: don't assume the entity exists\n      show_attribute: false,\n      show_state: true,\n      show_name: false,\n      name: \"Battery\",\n      show_icon: true,\n      state_background: false,\n      show_background: false,\n      visibility: [\n        {\n          condition: \"state\",\n          entity: battery_entity.entity_id,\n          state_not: \"100\",\n        },\n      ],\n    };\n\n    const progress_button = {\n      entity: related_entities.filter(\n        (e) => e.original_name === \"Cleaning progress\"\n      )[0].entity_id, // TODO: don't assume the entity exists. Find a more universal way to identify\n      show_attribute: true,\n      show_state: true,\n      show_name: false,\n      name: \"Cleaning Progress\",\n      show_icon: true,\n      visibility: [\n        {\n          condition: \"state\",\n          entity: vacuum.entity_id,\n          state_not: \"docked\",\n        },\n      ],\n      icon: \"mdi:vacuum\",\n      state_background: true,\n      show_background: false,\n    };\n\n    const start_button = {\n      name: \"Start\",\n      icon: \"mdi:play\",\n      tap_action: {\n        action: \"call-service\",\n        target: {\n          entity_id: \"entity\",\n        },\n        service: \"vacuum.start\",\n      },\n      visibility: [\n        {\n          condition: \"state\",\n          entity: vacuum.entity_id,\n          state_not: \"cleaning\",\n        },\n        {\n          condition: \"state\",\n          entity: vacuum.entity_id,\n          state_not: \"returning\",\n        },\n      ],\n    };\n\n    const locate_button = {\n      name: \"Locate\",\n      icon: \"mdi:map-marker-question\",\n      show_last_changed: false,\n      tap_action: {\n        action: \"call-service\",\n        target: {\n          entity_id: \"entity\",\n        },\n        service: \"vacuum.locate\",\n      },\n      visibility: [\n        {\n          condition: \"state\",\n          entity: vacuum.entity_id,\n          state_not: \"docked\",\n        },\n      ],\n    };\n\n    const pause_button = {\n      name: \"Pause\",\n      icon: \"mdi:pause\",\n      state_background: true,\n      show_background: true,\n      visibility: [visibility_is_moving],\n      tap_action: {\n        action: \"call-service\",\n        target: {\n          entity_id: \"entity\",\n        },\n        service: \"vacuum.pause\",\n      },\n    };\n\n    const stop_button = {\n      name: \"Stop\",\n      icon: \"mdi:stop\",\n      state_background: true,\n      show_background: true,\n      visibility: [visibility_is_moving],\n      tap_action: {\n        action: \"call-service\",\n        target: {\n          entity_id: \"entity\",\n        },\n        service: \"vacuum.stop\",\n      },\n    };\n\n    const dock_button = {\n      name: \"Dock\",\n      icon: \"mdi:home-import-outline\",\n      show_last_changed: false,\n      tap_action: {\n        action: \"call-service\",\n        target: {\n          entity_id: \"entity\",\n        },\n        service: \"vacuum.return_to_base\",\n      },\n      visibility: [\n        {\n          condition: \"state\",\n          entity: vacuum.entity_id,\n          state_not: \"docked\",\n        },\n        {\n          condition: \"state\",\n          entity: vacuum.entity_id,\n          state_not: \"returning\",\n        },\n      ],\n    };\n\n    // Styling to not colorize the battery\n    const animation = `if (icon.getAttribute('icon') !== 'mdi:robot-vacuum') { icon.setAttribute('icon', \"mdi:robot-vacuum\")}`;\n    // const animation = `if (['cleaning','returning'].includes(hass.states['${vacuum.entity_id}'].state)) {icon.classList.add(\"robot-vacuum\")} else {icon.classList.remove(\"robot-vacuum\")}`;\n    // const animation = `if (hass.states['${status_code.entity_id}'].state === 'cleaning') {icon.classList.add(\"robot-vacuum\")} else {icon.classList.remove(\"robot-vacuum\")}`;\n    // const animation = `icon.classList.add(\"robot-vacuum-circle-only\")`;\n    // const show_docked_if_fully_charged = `\n    // if (hass.states['${status_code.entity_id}'].state === 'charging' && hass.states['${battery_entity.entity_id}'].state == 100) { // state might be string or int\n    //   card.querySelector('.bubble-state').innerText = hass.formatEntityState(hass.states['${vacuum.entity_id}'])\n    // }\n    // `;\n    const show_docked_if_fully_charged = `\n    let desired_modules = []\n    if (hass.states['${status_code.entity_id}'].state === 'charging' && hass.states['${battery_entity.entity_id}'].state == 100) { // state might be string or int\n      desired_modules = this.config.modules.filter(item => item !== \"get_state_attribute\")  \n    } else {\n      desired_modules = [...this.config.modules];\n      if (!desired_modules.includes(\"get_state_attribute\")) {\n          desired_modules.push(\"get_state_attribute\");\n      }\n    }\n\n    // Since we are only adding and removing the last module, we can just compare the length\n    if (this.config.modules.length !== desired_modules.length) { this.config.modules = desired_modules; }\n    `;\n\n    // Add a glow if theres any errors\n    // Only works because the error buttons are first\n    const error_glow_whole_card = `\n      let has_error = false;\n      for (i=1; i<= ${error_buttons.length}; i++ ) {\n        const container = card.querySelector(\\`.bubble-sub-button-\\${i}\\`)\n        if (!container.classList.contains('hidden')) {\n          has_error = true;\n          card.style.setProperty('--glow-color', 'var(--error-color)');\n          break;\n        }\n      }\n      card.classList.toggle('breathing-glow-alt', has_error) \n    `;\n\n    const styles = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(\n      animation,\n      show_docked_if_fully_charged,\n      error_glow_whole_card\n    );\n\n    cards.push({\n      type: \"custom:bubble-card\",\n      card_type: \"button\",\n      button_type: \"state\",\n      entity: vacuum.entity_id,\n      scrolling_effect: false,\n      show_attribute: false,\n      sub_button: [\n        ...error_buttons,\n        battery_button,\n        progress_button,\n        start_button,\n        pause_button,\n        // stop_button,\n        dock_button,\n      ],\n      card_layout: \"large\",\n      columns: 4,\n      styles,\n      modules: [..._helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES, \"get_state_attribute\"],\n      get_state_attribute: [\n        {\n          entity: status_code.entity_id, // TODO: don't assume the entity exists\n        },\n        {},\n        {},\n        {},\n      ],\n    });\n  });\n\n  // Return null if we have no cards\n  if (cards.length === 0) {\n    return null;\n  }\n\n  // Add the header\n  cards.unshift(sectionHeader(\"mdi:vacuum\", \"Cleaning\"));\n\n  // Return the cards\n  return cards;\n}\n\nfunction new_bubble_card_automation(entity) {\n  const toggle = {\n    action: \"toggle\",\n    confirmation: {\n      text: `This will toggle automation '${entity.attributes.friendly_name}'.`,\n    },\n  };\n\n  // TODO: Replace buttons with a hamburger menu that opens a popup with the buttons\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n    entity: entity.entity_id,\n    sub_button: [\n      {\n        entity: entity.entity_id,\n        show_name: false,\n        name: \"Trigger\",\n        icon: \"mdi:play\",\n        show_state: false,\n        state_background: false,\n        tap_action: {\n          action: \"call-service\",\n          target: {\n            entity_id: \"entity\",\n          },\n          data: {\n            skip_condition: false,\n          },\n          service: \"automation.trigger\",\n          confirmation: {\n            text: `This will run automation '${entity.attributes.friendly_name}'.`,\n          },\n        },\n        show_last_updated: false,\n        show_last_changed: false,\n        show_attribute: false,\n        attribute: \"icon\",\n      },\n      // {\n      //   entity: entity.entity_id,\n      //   show_name: false,\n      //   name: \"Force Trigger\",\n      //   icon: \"mdi:flash\",\n      //   show_state: false,\n      //   state_background: false,\n      //   tap_action: {\n      //     action: \"call-service\",\n      //     target: {\n      //       entity_id: \"entity\",\n      //     },\n      //     data: {\n      //       skip_condition: true,\n      //     },\n      //     service: \"automation.trigger\",\n      //     confirmation: {\n      //       text: `This will run automation '${entity.attributes.friendly_name}' regardless of current conditions.`,\n      //     },\n      //   },\n      //   show_last_updated: false,\n      //   show_last_changed: false,\n      //   show_attribute: false,\n      //   attribute: \"icon\",\n      // },\n      {\n        entity: entity.entity_id,\n        show_name: false,\n        name: \"Toggle Button\",\n        icon: \"mdi:power\",\n        state_background: false,\n        show_state: true,\n        tap_action: toggle,\n        show_last_updated: false,\n        show_last_changed: false,\n      },\n    ],\n    card_layout: \"large\",\n    styles: \".bubble-button-background {opacity: 0 !important;}\",\n    show_attribute: true,\n    show_last_updated: false,\n    show_last_changed: false,\n    attribute: \"last_triggered\",\n    tap_action: {\n      action: \"more-info\",\n    },\n    button_action: {\n      tap_action: {\n        action: \"more-info\",\n      },\n    },\n    double_tap_action: {\n      action: \"none\",\n    },\n    hold_action: {\n      action: \"none\",\n    },\n  };\n}\n\nfunction ScriptGrid(entities) {\n  const scripts = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(entities, {\n      domain: \"script\",\n    })\n    .sort((a, b) => {\n      const nameA = a.attributes?.friendly_name?.toLowerCase() || \"\";\n      const nameB = b.attributes?.friendly_name?.toLowerCase() || \"\";\n      return nameA.localeCompare(nameB);\n    });\n\n  // Create a card for each script\n  const cards = scripts.map((script) => new_bubble_card(script));\n\n  // Return null if we have no cards\n  if (cards.length === 0) {\n    return null;\n  }\n\n  // Add the header\n  cards.unshift(sectionHeader(\"mdi:script-text\", \"Scripts\"));\n\n  // Create grid to store the cards in\n  return _helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(cards);\n}\n\nfunction AutomationGrid(entities) {\n  const automations = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(entities, {\n      domain: \"automation\",\n    })\n    .sort((a, b) => {\n      const nameA = a.attributes?.friendly_name?.toLowerCase() || \"\";\n      const nameB = b.attributes?.friendly_name?.toLowerCase() || \"\";\n      return nameA.localeCompare(nameB);\n    });\n\n  // Create a card for each automation\n  const cards = automations.map((automation) =>\n    new_bubble_card_automation(automation)\n  );\n\n  // Return null if we have no cards\n  if (cards.length === 0) {\n    return null;\n  }\n\n  // Add the header\n  cards.unshift(sectionHeader(\"mdi:robot\", \"Automations\"));\n\n  // Create grid to store the cards in\n  return _helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(cards);\n}\n\nfunction sectionHeader(icon, name, styles = undefined) {\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"separator\",\n    modules: [\"default\"],\n    name,\n    icon,\n    card_layout: \"normal\",\n    styles,\n  };\n}\n\nfunction DailyLogCard(\n  entity,\n  history,\n  hidden_state,\n  date_format,\n  minimal_duration\n) {\n  const config = {\n    type: \"custom:logbook-card\",\n    entity: entity,\n  };\n\n  if (history !== undefined) {\n    config.history = history;\n  }\n\n  if (hidden_state !== undefined) {\n    config.hidden_state = hidden_state;\n  }\n\n  if (date_format !== undefined) {\n    config.date_format = date_format;\n  }\n\n  if (minimal_duration !== undefined) {\n    config.minimal_duration = minimal_duration;\n  }\n\n  return config;\n}\n\nfunction AreaStatePopUp(area, area_state_entity) {\n  function state_bubble_card(entity_id) {\n    return {\n      type: \"custom:bubble-card\",\n      card_type: \"button\",\n      modules: [\"default\"],\n      button_type: \"state\",\n      entity: entity_id,\n      show_last_changed: true,\n    };\n  }\n\n  function multi_log_card(entities, area_state_entity_id) {\n    let e = entities.map((entity) => {\n      return {\n        entity: entity,\n        hidden_state: [\"unavailable\", \"off\"],\n      };\n    });\n\n    e.push({\n      entity: area_state_entity_id,\n      hidden_state: [\"unavailable\", \"unknown\", \"on\"],\n    });\n\n    return {\n      type: \"custom:multiple-logbook-card\",\n      title: \"Source Sensors' History\",\n      history: 1,\n      date_format: \"hh:mm A\",\n      entities: e,\n    };\n  }\n\n  // Return null if we dont have an area_state_entity\n  if (area_state_entity === undefined) {\n    return null;\n  }\n\n  const MORE_INFO_CARD = {\n    type: \"custom:more-info-card\",\n    entity: area_state_entity.entity_id,\n    title: area.name,\n  };\n\n  const presenceHold = `switch.magic_areas_presence_hold_${area.area_id}`;\n  const state_bubble_cards = [...area_state_entity.attributes.presence_sensors]\n    .sort()\n    .filter((x) => x != presenceHold) // We later put it at the top\n    .map((x) => state_bubble_card(x));\n\n  return {\n    type: \"vertical-stack\",\n    cards: [\n      {\n        type: \"custom:bubble-card\",\n        card_type: \"pop-up\",\n        modules: [\"default\"],\n        hash: \"#occupancy\",\n        show_header: true,\n        button_type: \"state\",\n        entity: area_state_entity.entity_id,\n        name: area.name,\n        trigger_close: false,\n        icon: \"\",\n        show_name: true,\n        show_last_changed: true,\n        show_attribute: true,\n        attribute: \"states\",\n        show_state: false,\n        sub_button: [\n          {\n            entity: presenceHold,\n            show_state: false,\n            show_name: false,\n            name: \"Presence Hold\",\n            show_attribute: false,\n            show_last_updated: false,\n            show_last_changed: false,\n            tap_action: {\n              action: \"toggle\",\n            },\n          },\n        ],\n      },\n      // MORE_INFO_CARD,\n      state_bubble_card(presenceHold),\n      ...state_bubble_cards,\n      DailyLogCard(\n        area_state_entity.entity_id,\n        1,\n        [\"unavailable\", \"off\"],\n        \"hh:mm A\",\n        1\n      ),\n      multi_log_card(\n        [...area_state_entity.attributes.presence_sensors],\n        area_state_entity.entity_id\n      ),\n    ],\n  };\n}\n\nfunction temperatureCard(mergedEntityMetadata, area) {\n  const area_temperature_entity = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(\n    mergedEntityMetadata,\n    {\n      domain: \"sensor\",\n      translation_key: \"aggregate_temperature\",\n      platform: \"magic_areas\",\n      area_id: area.area_id,\n    }\n  )[0];\n\n  if (area_temperature_entity === undefined) {\n    return null;\n  }\n\n  const interior_temperature_entity = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(mergedEntityMetadata, {\n      domain: \"sensor\",\n      translation_key: \"aggregate_temperature\",\n      platform: \"magic_areas\",\n    })\n    .find((x) => {\n      return x.identifiers?.[0]?.[1] === \"magic_area_device_interior\";\n    });\n\n  const outdoor_temperature_entity =\n    mergedEntityMetadata[\"sensor.outdoor_temperature\"];\n  let outdoor_icon_threshold;\n  switch (outdoor_temperature_entity.attributes.unit_of_measurement) {\n    case \"°F\":\n      outdoor_icon_threshold = 32;\n      break;\n    case \"°C\":\n      outdoor_icon_threshold = 0;\n      break;\n    case \"K\":\n      outdoor_icon_threshold = 273.15;\n      break;\n    default:\n      outdoor_icon_threshold = 32; // default to Fahrenheit threshold if unit is unrecognized. TODO: Default to HA's default\n  }\n\n  const outdoor_icon =\n    outdoor_temperature_entity.state > outdoor_icon_threshold\n      ? \"mdi:sun-thermometer\"\n      : \"mdi:snowflake-thermometer\";\n\n  const sub_button = [];\n  if (interior_temperature_entity !== undefined) {\n    sub_button.push({\n      entity: interior_temperature_entity.entity_id,\n      name: \"Indoors\",\n      show_name: true,\n      show_state: true,\n      state_background: false,\n      show_background: true,\n    });\n  }\n\n  if (outdoor_temperature_entity !== undefined) {\n    sub_button.push({\n      entity: outdoor_temperature_entity.entity_id,\n      name: \"Outdoors\",\n      show_name: true,\n      show_state: true,\n      state_background: false,\n      show_background: true,\n      icon: outdoor_icon,\n    });\n  }\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n    auto_order: false,\n    button_type: \"state\",\n    entity: area_temperature_entity.entity_id,\n    name: \"Temperature\",\n    show_state: true,\n    show_last_changed: false,\n    show_name: false,\n    sub_button,\n    card_layout: \"large\",\n    grid_options: {\n      columns: \"full\",\n      rows: 1,\n    },\n    styles: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.bubbleStyleConditional2Row(`window.innerWidth <= ${_helpers_js__WEBPACK_IMPORTED_MODULE_0__.WIDE}`)\n    ),\n  };\n}\n\nfunction humidityCard(mergedEntityMetadata, area) {\n  const filter = {\n    domain: \"sensor\",\n    translation_key: \"aggregate_humidity\",\n    platform: \"magic_areas\",\n  };\n\n  const area_entity = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(mergedEntityMetadata, {\n    ...filter,\n    area_id: area.area_id,\n  })[0];\n\n  if (area_entity === undefined) {\n    return null;\n  }\n\n  const interior_entity = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(mergedEntityMetadata, filter)\n    .find((x) => {\n      return x.identifiers?.[0]?.[1] === \"magic_area_device_interior\";\n    });\n\n  const outdoor_entity = mergedEntityMetadata[\"sensor.main_weather_humidity\"];\n\n  const sub_button = [];\n  if (interior_entity !== undefined) {\n    sub_button.push({\n      entity: interior_entity.entity_id,\n      name: \"Indoors\",\n      show_name: true,\n      show_state: true,\n      state_background: false,\n      show_background: true,\n    });\n  }\n  if (outdoor_entity !== undefined) {\n    sub_button.push({\n      entity: outdoor_entity.entity_id,\n      name: \"Outdoors\",\n      show_name: true,\n      show_state: true,\n      state_background: false,\n      show_background: true,\n      icon: \"mdi:cloud-percent\",\n    });\n  }\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n    auto_order: false,\n    button_type: \"state\",\n    entity: area_entity.entity_id,\n    name: \"Humidity\",\n    show_state: true,\n    show_last_changed: false,\n    show_name: false,\n    sub_button,\n    card_layout: \"large\",\n    grid_options: {\n      columns: \"full\",\n      rows: 1,\n    },\n    styles: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.bubbleStyleConditional2Row(`window.innerWidth <= ${_helpers_js__WEBPACK_IMPORTED_MODULE_0__.WIDE}`)\n    ),\n  };\n}\n\nfunction carbonDioxideCard(mergedEntityMetadata, area) {\n  const filter = {\n    domain: \"sensor\",\n    translation_key: \"aggregate_carbon_dioxide\",\n    platform: \"magic_areas\",\n  };\n\n  const area_entity = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(mergedEntityMetadata, {\n    ...filter,\n    area_id: area.area_id,\n  })[0];\n\n  if (area_entity === undefined) {\n    return null;\n  }\n\n  const interior_entity = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(mergedEntityMetadata, filter)\n    .find((x) => {\n      return x.identifiers?.[0]?.[1] === \"magic_area_device_interior\";\n    });\n\n  const sub_button = [];\n  if (interior_entity !== undefined) {\n    sub_button.push({\n      entity: interior_entity.entity_id,\n      name: \"Indoors\",\n      show_name: true,\n      show_state: true,\n      state_background: false,\n      show_background: true,\n    });\n  }\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n    auto_order: false,\n    button_type: \"state\",\n    entity: area_entity.entity_id,\n    name: \"Carbon Dioxide\",\n    show_state: true,\n    show_last_changed: false,\n    show_name: false,\n    sub_button,\n    card_layout: \"large\",\n    grid_options: {\n      columns: \"full\",\n      rows: 1,\n    },\n    styles: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.bubbleStyleConditional2Row(`window.innerWidth <= ${_helpers_js__WEBPACK_IMPORTED_MODULE_0__.WIDE}`)\n    ),\n  };\n}\n\nfunction climate_control_grid(mergedEntityMetadata, area) {\n  let cards = [];\n\n  // Add the header\n  cards.push(sectionHeader(\"mdi:thermostat\", \"Climate Control\"));\n\n  // Add cards\n  cards.push(temperatureCard(mergedEntityMetadata, area));\n  cards.push(humidityCard(mergedEntityMetadata, area));\n  cards.push(carbonDioxideCard(mergedEntityMetadata, area));\n\n  // Get all climate entities (domain: \"climate\")\n  const climate_entities = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(\n    mergedEntityMetadata,\n    {\n      domain: \"climate\",\n      area_id: area.area_id,\n    }\n  );\n\n  // Get all entities tagged with \"climate\"\n  const climate_entities_tagged = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(mergedEntityMetadata, {\n      area_id: area.area_id,\n    })\n    .filter((x) => x.labels?.includes(\"climate\"));\n\n  // Merge and deduplicate entities based on entity_id\n  const combined_climate_entities = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.remove_hidden(\n    [...climate_entities, ...climate_entities_tagged].filter(\n      (entity, index, self) =>\n        index === self.findIndex((e) => e.entity_id === entity.entity_id)\n    )\n  );\n\n  // Create a card for each unique climate entity\n  combined_climate_entities.forEach((entity) => {\n    cards.push(new_bubble_card(entity));\n  });\n\n  // Remove null cards\n  cards = cards.filter((x) => x !== null);\n\n  // Return null if we only have the header\n  if (cards.length === 1) {\n    return null;\n  }\n\n  return _helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(cards);\n}\n\nfunction new_bubble_climate_card(entity_id) {\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"climate\",\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n    entity: entity_id,\n    sub_button: [\n      {\n        name: \"HVAC modes menu\",\n        select_attribute: \"hvac_modes\",\n        state_background: true,\n        show_background: true,\n        show_arrow: false,\n        show_attribute: false,\n      },\n      {\n        name: \"Presets\",\n        select_attribute: \"preset_modes\",\n        state_background: true,\n        show_background: true,\n        show_arrow: false,\n        show_name: false,\n        show_state: false,\n        show_attribute: false,\n        attribute: \"preset_mode\",\n      },\n      {\n        entity: entity_id,\n        name: \"Current Temperature\",\n        icon: \"mdi:thermometer\",\n        state_background: true,\n        show_background: true,\n        show_attribute: true,\n        attribute: \"current_temperature\",\n      },\n    ],\n    force_icon: false,\n    show_name: false,\n    show_state: false,\n    show_last_changed: false,\n    show_attribute: false,\n    attribute: \"hvac_action\",\n    rows: \"1\",\n    card_layout: \"large\",\n    show_last_updated: false,\n    show_icon: true,\n    scrolling_effect: true,\n    styles:\n      \".bubble-temperature-container { background-color: ${state !== 'off' ? 'var(--bubble-accent-color, var(--bubble-default-color))' : 'var(--bubble-climate-button-background-color, var(--bubble-secondary-background-color, var(--card-background-color, var(--ha-card-background))))'};}\",\n  };\n}\n\nfunction new_bubble_card(entity) {\n  if (entity === undefined) {\n    return null;\n  }\n\n  if (entity.domain == \"climate\") {\n    return new_bubble_climate_card(entity.entity_id);\n  }\n\n  if (entity.domain == \"timer\") {\n    return new_bubble_timer_card(entity);\n  }\n\n  if (entity.domain == \"binary_sensor\") {\n    return new_bubble_card_binary_sensor(entity);\n  }\n\n  if (entity.domain == \"automation\") {\n    return new_bubble_card_automation(entity);\n  }\n\n  // TODO: support all domains\n  return new_generic_bubble_card(entity);\n}\n\nfunction new_bubble_card_binary_sensor(entity) {\n  let card = new_generic_bubble_card(entity);\n\n  // Only show problem cards while there's a problem\n  if (entity.attributes?.device_class === \"problem\") {\n    card.visibility.push({\n      condition: \"state\",\n      entity: entity.entity_id,\n      state: \"on\",\n    });\n    card.modules.push(\"colorize\", \"animate\");\n  }\n\n  return card;\n}\n\nfunction new_generic_bubble_card(entity) {\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n    entity: entity.entity_id,\n    button_type: \"state\",\n    show_state: true,\n    show_last_changed: true,\n    show_attribute: false,\n    // Subbutton looks better on normal screen but smaller screens it looks worse\n    // TODO: custom style to adjust on screen size\n    // sub_button: [\n    //   {\n    //     entity: entity.entity_id,\n    //     show_state: true,\n    //     name: \"State\",\n    //   },\n    // ],\n    visibility: [],\n  };\n}\n\nfunction new_bubble_timer_card(entity) {\n  // TODO: Switch to something better like https://github.com/Clooos/Bubble-Card/discussions/937\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    button_type: \"state\",\n    entity: entity.entity_id,\n    show_attribute: false,\n    sub_button: [\n      {\n        entity: entity.entity_id,\n        show_attribute: true,\n        attribute: \"finishes_at\",\n        visibility: [\n          {\n            condition: \"state\",\n            entity: entity.entity_id,\n            state: \"active\",\n          },\n        ],\n        show_icon: false,\n      },\n      {\n        entity: entity.entity_id,\n        tap_action: {\n          action: \"call-service\",\n          target: {\n            entity_id: \"entity\",\n          },\n          service: \"timer.start\",\n        },\n        icon: \"mdi:play\",\n        visibility: [\n          {\n            condition: \"state\",\n            entity: entity.entity_id,\n            state_not: \"active\",\n          },\n        ],\n        name: \"Start\",\n      },\n      {\n        entity: entity.entity_id,\n        tap_action: {\n          action: \"call-service\",\n          target: {\n            entity_id: \"entity\",\n          },\n          service: \"timer.pause\",\n        },\n        icon: \"mdi:pause\",\n        visibility: [\n          {\n            condition: \"state\",\n            entity: entity.entity_id,\n            state: \"active\",\n          },\n        ],\n        name: \"Pause\",\n      },\n    ],\n    show_state: true,\n    attribute: \"finishes_at\",\n    show_last_changed: true,\n  };\n}\n\ncustomElements.define(\"ll-strategy-view-magic-area\", AreaView);\n\n\n//# sourceURL=webpack://magic-dashboard-strategy/./src/views/area.js?");

/***/ }),

/***/ "./src/views/helpers.js":
/*!******************************!*\
  !*** ./src/views/helpers.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddCardMod: () => (/* binding */ AddCardMod),\n/* harmony export */   BUBBLE_MODULES: () => (/* binding */ BUBBLE_MODULES),\n/* harmony export */   CARD_MOD: () => (/* binding */ CARD_MOD),\n/* harmony export */   DESKTOP: () => (/* binding */ DESKTOP),\n/* harmony export */   MOBILE: () => (/* binding */ MOBILE),\n/* harmony export */   TABLET: () => (/* binding */ TABLET),\n/* harmony export */   WIDE: () => (/* binding */ WIDE),\n/* harmony export */   alertBadge: () => (/* binding */ alertBadge),\n/* harmony export */   bubbleCSSImport: () => (/* binding */ bubbleCSSImport),\n/* harmony export */   bubbleStyleConditional2Row: () => (/* binding */ bubbleStyleConditional2Row),\n/* harmony export */   entityExists: () => (/* binding */ entityExists),\n/* harmony export */   filterEntitiesByProperties: () => (/* binding */ filterEntitiesByProperties),\n/* harmony export */   filterEntitiesToMagicArea: () => (/* binding */ filterEntitiesToMagicArea),\n/* harmony export */   filterEntityByArea: () => (/* binding */ filterEntityByArea),\n/* harmony export */   filterEntityByIntegration: () => (/* binding */ filterEntityByIntegration),\n/* harmony export */   filterEntityByPlatform: () => (/* binding */ filterEntityByPlatform),\n/* harmony export */   filterEntityKeysByDomain: () => (/* binding */ filterEntityKeysByDomain),\n/* harmony export */   hideOnMobile: () => (/* binding */ hideOnMobile),\n/* harmony export */   newGrid: () => (/* binding */ newGrid),\n/* harmony export */   remove_hidden: () => (/* binding */ remove_hidden),\n/* harmony export */   visibilityIsUnknownUnavailable: () => (/* binding */ visibilityIsUnknownUnavailable),\n/* harmony export */   visibilityNotUnknownUnavailable: () => (/* binding */ visibilityNotUnknownUnavailable),\n/* harmony export */   wrapInBubbleCardStyleIIFE: () => (/* binding */ wrapInBubbleCardStyleIIFE)\n/* harmony export */ });\nfunction entityExists(hass, entityId) {\n  return entityId in hass.states;\n}\n\nconst MOBILE = 0;\nconst TABLET = 768;\nconst DESKTOP = 1024;\nconst WIDE = 1280;\n\nfunction hideOnMobile() {\n  const mobile = 0;\n  const tablet = 768;\n  const desktop = 1024;\n  const wide = 1280;\n\n  return {\n    condition: \"screen\",\n    media_query: `(min-width: ${tablet}px)`,\n  };\n}\n\nfunction filterEntitiesToMagicArea(devices, entities, area_id) {\n  const magic_area_device_ids = devices\n    .filter((device) => device.area_id === area_id)\n    .filter((device) => device.model === \"Magic Area\")\n    .map((device) => device.id);\n  return entities.filter((entity) =>\n    magic_area_device_ids.includes(entity.device_id)\n  );\n}\n\nfunction newGrid(cards, column_span) {\n  // Ensure cards is always an array\n  cards = Array.isArray(cards) ? cards : [cards];\n\n  // Remove any null or undefined cards\n  cards = filterFalsy(cards);\n\n  // Return null if we have no cards\n  if (cards.length === 0) {\n    return null;\n  }\n\n  let grid = {\n    type: \"grid\",\n    cards,\n  };\n\n  if (column_span > 0) {\n    grid[\"column_span\"] = column_span;\n  }\n\n  return grid;\n}\n\nfunction filterEntityKeysByDomain(obj, domain) {\n  return Object.keys(obj)\n    .filter((key) => key.startsWith(`${domain}.`))\n    .reduce((acc, key) => {\n      acc[key] = obj[key];\n      return acc;\n    }, {});\n}\n\n/**\n * Converts entities to an array if they are an object.\n *\n * @param {Array|Object|null|undefined} entities - An array, an object of entity objects, or null/undefined.\n * @returns {Array} - An array of entity objects (or an empty array if input is null/undefined).\n */\nfunction convertEntitiesToArray(entities) {\n  if (!entities) return []; // Handles null, undefined, and falsy values safely\n  return Array.isArray(entities) ? entities : Object.values(entities);\n}\n\n/**\n * Filters entities based on their area ID.\n *\n * @param {Array|Object} entities - An array or an object of entity objects.\n * @param {string} areaId - The area ID to filter by.\n * @returns {Array} - A filtered array of entities that match the specified area ID.\n */\nfunction filterEntityByArea(entities, areaId, includeHidden = false) {\n  let entityArray = convertEntitiesToArray(entities).filter(\n    (entity) => entity.area_id === areaId\n  );\n\n  return includeHidden ? entityArray : remove_hidden(entityArray);\n}\n\n/**\n * Filters entities based on their platform.\n *\n * @param {Array|Object} entities - An array or an object of entity objects.\n * @param {string} platform - The platform name to filter by.\n * @returns {Array} - A filtered array of entities matching the platform.\n */\nfunction filterEntityByPlatform(entities, platform) {\n  const entityArray = convertEntitiesToArray(entities);\n  return entityArray.filter((entity) => entity.platform === platform);\n}\n\n/**\n * Alias for filterEntityByPlatform\n *\n * @function filterEntityByIntegration\n * @see filterEntityByPlatform\n */\nconst filterEntityByIntegration = filterEntityByPlatform;\n\n/**\n * Gets the value from a nested property (supports dot notation).\n *\n * @param {Object} obj - The object to retrieve the value from.\n * @param {string} path - The dot notation path to the property.\n * @returns {any} - The value at the specified path, or undefined if not found.\n */\nfunction getNestedProperty(obj, path) {\n  return path\n    .split(\".\")\n    .reduce((acc, part) => (acc ? acc[part] : undefined), obj);\n}\n\n/**\n * Filters entities based on multiple properties and values.\n *\n * @param {Array|Object} entities - An array or an object of entity objects.\n * @param {Object} filters - An object where keys are property names (or dot notation paths) and values are the values to filter by\n * @returns {Array} - A filtered array of entities that match the specified properties and values.\n *\n * @example\n * const entities = [\n *   { entity_id: 'sensor.living_room', attributes: { device_class: 'occupancy' }, platform: 'magic_areas' },\n *   { entity_id: 'sensor.kitchen', attributes: { device_class: 'temperature' }, platform: 'magic_areas' },\n *   { entity_id: 'sensor.bedroom', attributes: { device_class: 'occupancy' }, platform: 'magic_areas' }\n * ];\n *\n * const filters = {\n *   'attributes.device_class': 'occupancy', // Filtering based on a nested property\n *   platform: 'magic_areas' // Filtering based on a top-level property\n * };\n *\n * const filteredEntities = filterEntitiesByProperties(entities, filters);\n * console.log(filteredEntities);\n * // Output:\n * // [\n * //   { entity_id: 'sensor.living_room', attributes: { device_class: 'occupancy' }, platform: 'magic_areas' },\n * //   { entity_id: 'sensor.bedroom', attributes: { device_class: 'occupancy' }, platform: 'magic_areas' }\n * // ]\n */\nfunction filterEntitiesByProperties(entities, filters) {\n  const entityArray = convertEntitiesToArray(entities);\n\n  return entityArray.filter((entity) => {\n    return Object.entries(filters).every(([path, value]) => {\n      const entityValue = getNestedProperty(entity, path);\n      return entityValue === value;\n    });\n  });\n}\n\n/**\n * Filters out `null` and `undefined` values from an array.\n *\n * This function creates a new array by filtering out any elements that are `null` or `undefined`.\n * It uses loose inequality (`!=`) to remove both `null` and `undefined` from the array,\n * while leaving all other values (including other falsy values like `false`, `0`, `''`, etc.) intact.\n *\n * @param {Array} arr - The array to filter.\n * @returns {Array} - A new array with `null` and `undefined` values removed.\n *\n * @example\n * const data = [1, null, 2, undefined, 3];\n * const result = filterFalsy(data);\n * console.log(result);  // Output: [1, 2, 3]\n */\nfunction filterFalsy(arr) {\n  return arr.filter((x) => x != null); // Will remove both null and undefined\n}\n\nfunction alertBadge() {\n  return {\n    type: \"custom:auto-entities\",\n    filter: {\n      include: [\n        {\n          domain: \"alert\",\n          state: \"on\",\n          options: {\n            type: \"entity\",\n            content_info: \"name\",\n            icon_color: \"red\",\n          },\n        },\n      ],\n      exclude: [],\n    },\n    show_empty: true,\n    card_param: \"chips\",\n    card: {\n      type: \"custom:mushroom-chips-card\",\n      alignment: \"center\",\n    },\n    grid_options: {\n      columns: \"full\",\n    },\n    column_span: 12,\n  };\n}\n\n/**\n * Wraps a given string inside an Immediately Invoked Function Expression (IIFE) as it would be accepted by Bubble Card's style property.\n *\n * @param {...string} js - One or more JavaScript statements to wrap inside an IIFE.\n * @returns {string} - A template literal string with the js enclosed in an IIFE.\n *\n */\nfunction wrapInBubbleCardStyleIIFE(...js) {\n  return `\n\\${(() => {\n  ${js.join(\";\\n  \")}\n})()}\n`;\n}\n\n/**\n * Generates a Home Assistant condition that ensures an entity is neither \"unknown\" nor \"unavailable\".\n *\n * This function creates an \"and\" condition block that checks whether the given entity's state\n * is neither \"unknown\" nor \"unavailable\". This is useful in automations, scripts, and Lovelace\n * configurations where you need to ensure an entity is in a valid state before proceeding.\n *\n * @param {object|string} entity - The entity object or entity ID to check.\n * @returns {object} - A Home Assistant condition object ensuring the entity is valid.\n *\n * @example\n * const condition = visibilityNotUnknownUnavailable(\"sensor.my_sensor\");\n * console.log(condition);\n * // Output:\n * // {\n * //   \"condition\": \"and\",\n * //   \"conditions\": [\n * //     { \"condition\": \"state\", \"entity\": \"sensor.my_sensor\", \"state_not\": \"unknown\" },\n * //     { \"condition\": \"state\", \"entity\": \"sensor.my_sensor\", \"state_not\": \"unavailable\" }\n * //   ]\n * // }\n */\nfunction visibilityNotUnknownUnavailable(entity) {\n  const entity_id = entity?.entity_id || entity;\n\n  return {\n    condition: \"and\",\n    conditions: [\n      {\n        condition: \"state\",\n        entity: entity_id,\n        state_not: \"unknown\",\n      },\n      {\n        condition: \"state\",\n        entity: entity_id,\n        state_not: \"unavailable\",\n      },\n    ],\n  };\n}\n\nfunction visibilityIsUnknownUnavailable(entity) {\n  const entity_id = entity?.entity_id || entity;\n\n  return {\n    condition: \"or\",\n    conditions: [\n      {\n        condition: \"state\",\n        entity: entity_id,\n        state: \"unknown\",\n      },\n      {\n        condition: \"state\",\n        entity: entity_id,\n        state: \"unavailable\",\n      },\n    ],\n  };\n}\n\n/**\n * Generates a JavaScript conditional statement to dynamically set a bubble card as large-2-rows vs just large.\n * You should set it as large then add this wrapped in an IIFE in styles\n *\n * @param {string} condition - The condition to evaluate inside the generated `if` statement. When true, will be large. When false will be large-2-rows\n * @returns {string} - A JavaScript conditional statement as a string.\n *\n * @example\n * const jsCode = styleConditional2Row(\"hass.states['person.name'].state === 'home'\");\n * console.log(jsCode);\n * // Output:\n * // \"if (hass.states['person.name'].state === 'home') {card.classList.remove('rows-2')} else {card.classList.add('rows-2')}\"\n *\n * @example\n * helpers.wrapInBubbleCardStyleIIFE(helpers.bubbleStyleConditional2Row('window.innerWidth <= 768'))\n */\nfunction bubbleStyleConditional2Row(condition) {\n  return `if (${condition}) {card.classList.add('rows-2')} else {card.classList.remove('rows-2')}`;\n}\n\n/**\n * Generates a JavaScript conditional statement to dynamically set a bubble card as large-2-rows vs just large.\n * You should set it as large then add this wrapped in an IIFE in styles\n *\n * @param {string} condition - The condition to evaluate inside the generated `if` statement. When true, will be large. When false will be large-2-rows\n * @returns {string} - A JavaScript conditional statement as a string.\n *\n * @example\n * const jsCode = styleConditional2Row(\"hass.states['person.name'].state === 'home'\");\n * console.log(jsCode);\n * // Output:\n * // \"if (hass.states['person.name'].state === 'home') {card.classList.remove('rows-2')} else {card.classList.add('rows-2')}\"\n *\n * @example\n * helpers.wrapInBubbleCardStyleIIFE(helpers.bubbleStyleConditional2Row('window.innerWidth >= 768'))\n */\nfunction bubbleCSSImport() {\n  return wrapInBubbleCardStyleIIFE(`\n    if (!card.magicCSSAdded){\n      card.magicCSSAdded = true\n\n      // Create a <link> element inside the shadow root\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = '/local/strategies/magic-dashboard-strategy/animations.css?v=' + new Date().getTime();\n\n      // Append the <link> element to the shadow root\n      card.appendChild(link);\n    }\n    `);\n}\n\n// export const BUBBLE_MODULES = ['default', 'state_attribute', 'colorize', 'animate']\nconst BUBBLE_MODULES = [\"default\", \"state_attribute\"];\n\nconst CARD_MOD = {\n  style: `\n@import url('/hacsfiles/magic-dashboard-strategy/colorize.css');\n@import url('/hacsfiles/magic-dashboard-strategy/animations.css');\n    `,\n};\n\nfunction AddCardMod(input) {\n  if (input === undefined || input === null) {\n    return;\n  }\n\n  // Detect array of sections\n  if (Array.isArray(input)) {\n    const tmp = input.filter((x) => x !== undefined && x !== null);\n    if (tmp.length === 0) {\n      return;\n    }\n    if (tmp[0].hasOwnProperty(\"cards\")) {\n      input.forEach((card) => {\n        AddCardMod(card);\n      });\n      return;\n    }\n  }\n\n  // Array of cards\n  if (Array.isArray(input)) {\n    input.forEach((card) => {\n      if ((card !== undefined) & (card !== null)) {\n        card[\"card_mod\"] = CARD_MOD;\n      }\n    });\n    return;\n  }\n\n  // Object that has cards\n  if (input.hasOwnProperty(\"cards\") && Array.isArray(input.cards)) {\n    input.cards.forEach((card) => {\n      if (card !== undefined && card !== null) {\n        card[\"card_mod\"] = CARD_MOD;\n      }\n    });\n    return;\n  }\n}\n\n/**\n * Filters out entities that are marked as hidden or disabled.\n *\n * This function removes any entities that have a non-null `hidden_by` or `disabled_by` property.\n *\n * @param {Array} entities - The array of entities to filter.\n * @returns {Array} A new array containing only the entities that are not hidden or disabled.\n */\nfunction remove_hidden(entities) {\n  return entities.filter(\n    (x) =>\n      !(x.hasOwnProperty(\"hidden_by\") && x.hidden_by !== null) &&\n      !(x.hasOwnProperty(\"disabled_by\") && x.disabled_by !== null)\n  );\n}\n\n\n//# sourceURL=webpack://magic-dashboard-strategy/./src/views/helpers.js?");

/***/ }),

/***/ "./src/views/people.js":
/*!*****************************!*\
  !*** ./src/views/people.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/views/helpers.js\");\n\n\nclass PeopleView {\n  static async generate(config, hass) {\n    const { devices, entities, mergedEntityMetadata } = config;\n\n    const sections = [];\n\n    const people = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(mergedEntityMetadata, {\n      domain: \"person\",\n    });\n    people.forEach((person) => {\n      const cards = [\n        SPACER_CARD,\n        headerCard2(person, mergedEntityMetadata),\n        phoneCard(person, mergedEntityMetadata),\n        // alarmCard(person),\n      ];\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.AddCardMod(cards);\n      sections.push(_helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(cards));\n    });\n\n    const max_columns = Math.min(4, people.length);\n\n    return {\n      type: \"sections\",\n      max_columns,\n      sections,\n      badges: [_helpers_js__WEBPACK_IMPORTED_MODULE_0__.alertBadge()],\n    };\n  }\n}\n\nconst SPACER_CARD = {\n  type: \"heading\",\n  icon: \"\",\n  heading_style: \"title\",\n  visibility: [\n    {\n      condition: \"screen\",\n      media_query: \"(min-width: 0px) and (max-width: 767px)\",\n    },\n  ],\n  grid_options: {\n    rows: 0.25,\n  },\n};\n\nfunction headerCard2(person, entities) {\n  const sub_button = [];\n\n  const time_to_home = `sensor.${person.attributes.id}_to_home`; // TODO: actually check that it exists\n  if (time_to_home in entities) {\n    sub_button.push({\n      entity: time_to_home,\n      name: \"Time To Home\",\n      state_background: false,\n      show_background: false,\n      show_icon: true,\n      show_state: true,\n      show_name: false,\n      show_attribute: false,\n      show_last_updated: true,\n      visibility: [\n        {\n          condition: \"state\",\n          entity: person.entity_id,\n          state_not: \"home\",\n        },\n      ],\n    });\n  }\n\n  // TODO: be smarter about what device tracker we consider their phone\n  // For now we just assume it exists and that its the first device tracker listed\n  // We should instead parse them all, looking for one that is from the right platform/integration\n  // Then maybe return multiple cards for all phones we find\n  const phone_entity_id = person.attributes.device_trackers[0];\n  const phone_device_id = entities[phone_entity_id].device_id;\n  const phone_sensor_prefix = phone_entity_id.split(\".\")[1];\n  const ble_sensor = `sensor.${phone_sensor_prefix}_ble_transmitter`;\n  let ble_idx = undefined;\n  let ble_area_sensor = undefined;\n\n  if (\n    entities[ble_sensor] &&\n    entities[ble_sensor].attributes &&\n    entities[ble_sensor].attributes.id\n  ) {\n    const ble_uuid = entities[ble_sensor].attributes.id.replace(/-/g, \"\");\n    ble_area_sensor = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(entities, {\n      platform: \"bermuda\",\n      // TODO: fall back to the normal \"Area\" sensor if this doesn't exist.\n      // We use \"Last Seen\" because we only show this value if the device is at home and ble is on.\n      // So even if its not currently seen by the BLE sensors, is likely still at its last seen area.\n      unique_id: `${ble_uuid}_area_last_seen`,\n    });\n    console.log(ble_area_sensor);\n  }\n\n  const visible_when_ble_bad = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityIsUnknownUnavailable(\n    ble_area_sensor[0].entity_id // TODO: clean up so we aren't dealing with ble_area_sensor as an array\n  );\n  visible_when_ble_bad[\"conditions\"].push({\n    condition: \"state\",\n    entity: ble_sensor,\n    state_not: \"Transmitting\",\n  });\n\n  // TODO: make the tap action of the location name open a popup with the:\n  // person entity\n  // bermuda entity\n  // place entity\n  // Link to the map\n  // From there the user can click on any of them to open the more info dialog\n  const location =\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.filterEntitiesByProperties(entities, {\n      platform: \"places\",\n      \"attributes.devicetracker_entityid\": person.entity_id,\n    })[0] ?? person;\n  sub_button.push({\n    entity: location.entity_id,\n    name: \"Location\",\n    show_state: true,\n    state_background: false,\n    show_background: false,\n    show_last_changed: false,\n    show_icon: true,\n    visibility: [visible_when_ble_bad], // TODO: handle visibility when ble_area_sensor is undefined\n    // icon: locationIcon(entities, location, person),\n  });\n\n  // TODO: check if this still works for when ble_area_sensor is undefined\n  if (ble_area_sensor.length > 0) {\n    ble_area_sensor = ble_area_sensor[0];\n    console.log(ble_area_sensor.entity_id);\n    sub_button.push({\n      name: \"BLE Area\",\n      entity: ble_area_sensor.entity_id,\n      show_name: false,\n      show_last_changed: false,\n      show_state: true,\n      show_icon: true,\n      state_background: true,\n      show_background: false,\n      visibility: [\n        // We check that BLE is transmitting because bermuda can take a little longer to switch to unknown\n        {\n          condition: \"state\",\n          entity: ble_sensor,\n          state: \"Transmitting\",\n        },\n        _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(ble_area_sensor.entity_id),\n      ],\n    });\n    ble_idx = sub_button.length - 1;\n  }\n\n  // Add a link to the underlying phone device\n  sub_button.push({\n    name: \"Phone Link\",\n    icon: \"mdi:information-variant-circle-outline\",\n    state_background: false,\n    show_background: false,\n    tap_action: {\n      action: \"navigate\",\n      navigation_path: `/config/devices/device/${phone_device_id}`,\n    },\n  });\n\n  const bubble_icon = {\n    \"background-image\": `url(\"${person.attributes.entity_picture}\")`,\n    \"background-size\": \"cover\",\n    \"--mdc-icon-size\": \"48px !important\",\n    \"clip-path\": \"circle()\",\n    \"margin-left\": \"0px !important\",\n    \"margin-right\": \"3% !important\",\n  };\n  let styles = `\n  .bubble-icon {\n    ${Object.entries(bubble_icon)\n      .map(([key, value]) => `${key}: ${value};`)\n      .join(\"\\n    \")}\n  }\n  .bubble-name-container {\n    margin-right: 0px !important;\n  }\n`;\n\n  // Make it dynamically switch to \"large-2-rows\" if theres 2 items\n  // We don't always have it that way because if theres only 1,\n  // then its not vertically centered\n  styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(\n    // Make 2 row on small screens\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.bubbleStyleConditional2Row(\n      `(hass.states['${person.entity_id}'].state !== 'home') & (window.innerWidth <= 480)`\n    ),\n\n    // Hide name when too small\n    `\n    if ((hass.states['${person.entity_id}'].state !== 'home') & (window.innerWidth <= 480)) {\n      card.querySelector(\".bubble-name\").style.display = 'none';\n    } else {\n      card.querySelector(\".bubble-name\").style.removeProperty('display');\n    }\n    `,\n\n    // Make profile pic clickable\n    `\n    const clickable = card.querySelector('.bubble-icon');\n    if (clickable.style.cursor !== 'pointer') {\n      clickable.style.cursor = 'pointer';\n      clickable.addEventListener(\"click\", function() {\n        const event = new Event('hass-more-info', { bubbles: false, composed: true });\n\n        // Dispatch the event with the entity ID\n        event.detail = { entityId: '${person.entity_id}' };\n        card.dispatchEvent(event);\n      });\n    }\n`,\n    // Hide last updated conditionally\n    `\n    // Only show \"last updated\" on time to home sensor when it hasn't been updated in lastUpdatedLimitMinutes minutes\n    const lastUpdatedLimitMinutes = 6;\n    const lastUpdatedLimit = new Date(Date.now() - lastUpdatedLimitMinutes * 60 * 1000);\n    const time_to_home_updated_recently = new Date(hass.states['${time_to_home}'].last_updated) >= lastUpdatedLimit;\n    if (time_to_home_updated_recently) {\n      const button = card.querySelector(\".bubble-sub-button-1 .bubble-sub-button-name-container\");\n      button.textContent = button.textContent.replace(/\\\\s·\\\\s\\\\d+\\\\s\\\\w+\\\\sago/, '')\n    }\n`,\n    // Update icon based on place type if not zone\n    `\n    // Var to hold new icon\n    let location_based_icon;\n    const location = hass.states['${location.entity_id}'];\n\n    // If you are in a zone, use that zone's id\n    const person_state = hass.states['${person.entity_id}'].state;\n    if (person_state !== 'not_home') {\n      const zone_id = \\`zone.\\${person_state}\\`; // TODO: Fix when this bug is fixed https://github.com/home-assistant/core/issues/123504#issuecomment-2676563143\n      try { location_based_icon = hass.states[zone_id].attributes.icon; } catch {}\n    }\n\n    // We are not in a zone so let's get an icon based on the place_type\n    else if (location?.attributes?.place_type) {\n      switch (location.attributes.place_type.toLowerCase()) { // Todo: see if we can get the higher level of place type like 'shop' instead of 'supermarket'\n        case \"house\":\n          location_based_icon = \"mdi:home-switch\";\n          break;\n        case \"store\":\n        case \"shopping\":\n        case \"supermarket\":\n          location_based_icon = \"mdi:store\";\n          break;\n        case \"restaurant\":\n          location_based_icon = \"mdi:food\";\n          break;\n        case \"cafe\":\n          location_based_icon = \"mdi:coffee\";\n          break;\n        case \"bar\":\n          location_based_icon = \"mdi:beer\";\n          break;\n        case \"park\":\n          location_based_icon = \"mdi:tree\";\n          break;\n        case \"school\":\n          location_based_icon = \"mdi:school\";\n          break;\n        case \"hospital\":\n          location_based_icon = \"mdi:hospital\";\n          break;\n        case \"bank\":\n          location_based_icon = \"mdi:bank\";\n          break;\n        case \"post_office\":\n          location_based_icon = \"mdi:mailbox\";\n          break;\n        case \"place_of_worship\":\n          location_based_icon = \"mdi:church\";\n          break;\n        case \"theater\":\n          location_based_icon = \"mdi:theater\";\n          break;\n        case \"gym\":\n          location_based_icon = \"mdi:dumbbell\";\n          break;\n        case \"gas_station\":\n          location_based_icon = \"mdi:gas-station\";\n          break;\n        case \"pharmacy\":\n          location_based_icon = \"mdi:prescription\";\n          break;\n      } // End switch\n  } // End if place_type exists\n\n  // Update the icon\n  if (location_based_icon !== undefined && subButtonIcon[1].icon !== location_based_icon) {\n    subButtonIcon[1].setAttribute(\"icon\", location_based_icon);\n  }\n`\n  );\n\n  // Add room icon\n  // TODO: only do do this is we have a ble_area_sensor\n  // TODO: just make a PR to make the icon a part of the entity https://github.com/agittins/bermuda/issues/513\n  // TODO: show last updated if its not updated in the last 5 minutes and the normal area sensor is unknown\n  if (ble_idx !== undefined) {\n    styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(\n      `\n      let ble_area_id = hass.states['${ble_area_sensor.entity_id}'].attributes.area_id;\n      if (!ble_area_id) { ble_area_id = hass.states['${ble_area_sensor.entity_id}'].state.toLowerCase().replace(/ /g, \"_\")}\n      \n      if (ble_area_id) {\n        hass.callWS({ type: \"config/area_registry/list\" }).then((areas) => {\n          const ble_area = areas.find((area) => area.area_id === ble_area_id);\n          if (ble_area && ble_area.icon) {\n            this.config.sub_button[${ble_idx}].icon = ble_area.icon;\n          }\n        });\n      }\n      `\n    );\n  }\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"separator\",\n    card_layout: \"large\",\n    icon: person.attributes.entity_picture,\n    styles,\n    sub_button,\n    name: person.attributes.friendly_name,\n    grid_options: {\n      columns: \"full\",\n      rows: 0.6,\n    },\n  };\n}\n\nfunction phoneCard(person, entities) {\n  // TODO: be smarter about what device tracker we consider their phone\n  // For now we just assume it exists and that its the first device tracker listed\n  // We should instead parse them all, looking for one that is from the right platform/integration\n  // Then maybe return multiple cards for all phones we find\n  const phone_entity_id = person.attributes.device_trackers[0];\n\n  // TODO: Make all the subbuttons first test that the entity exists\n  // When we do, we must also account for that in the styles\n  const phone_sensor_prefix = phone_entity_id.split(\".\")[1];\n\n  // TODO: Make all the subbuttons first test that the entity exists\n  const bluetooth_connection_sensor = `sensor.${phone_sensor_prefix}_bluetooth_connection`;\n  const phone_state_sensor = `sensor.${phone_sensor_prefix}_phone_state`;\n  const ringer_mode_sensor = `sensor.${phone_sensor_prefix}_ringer_mode`;\n  const volume_level_ringer_sensor = `sensor.${phone_sensor_prefix}_volume_level_ringer`;\n  const sleep_confidence_sensor = `sensor.${phone_sensor_prefix}_sleep_confidence`;\n  const remaining_charge_time_sensor = `sensor.${phone_sensor_prefix}_remaining_charge_time`;\n  const alarm_sensor = `sensor.${phone_sensor_prefix}_next_alarm`;\n  const steps_sensor = `sensor.${phone_sensor_prefix}_daily_steps`;\n  const ble_sensor = `sensor.${phone_sensor_prefix}_ble_transmitter`;\n\n  // Config vars\n  const sleep_confidence_visible_threshold = 80; // 90 = visible if sleep confidence is at least 90%\n  const sleep_confidence_color = \"var(--purple-color)\"; // Color of the sleep confidence icon\n\n  // TODO: Exit if no subbuttons exist\n\n  const show_background = true;\n  const state_background = false;\n\n  // Subbuttons\n  // TODO: Only add subbutton if the entity exists\n  const sub_button = [];\n\n  // Add sleep sensor\n  sub_button.push({\n    entity: sleep_confidence_sensor,\n    name: \"Sleep Confidence\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    show_attribute: false,\n    show_name: false,\n    visibility: [\n      {\n        condition: \"numeric_state\",\n        entity: sleep_confidence_sensor,\n        above: sleep_confidence_visible_threshold - 1,\n      },\n    ],\n  });\n  const SLEEP_CONFIDENCE_IDX = sub_button.length - 1;\n\n  sub_button.push({\n    entity: `binary_sensor.${phone_sensor_prefix}_interactive`,\n    name: \"Interactive\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    visibility: [\n      {\n        condition: \"state\",\n        entity: `binary_sensor.${phone_sensor_prefix}_interactive`,\n        state_not: \"off\",\n      },\n    ],\n  });\n  const INTERACTIVE_IDX = sub_button.length - 1;\n  sub_button.push({\n    entity: `sensor.${phone_sensor_prefix}_do_not_disturb_sensor`,\n    name: \"Do Not Disturb\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    visibility: [\n      {\n        condition: \"state\",\n        entity: `sensor.${phone_sensor_prefix}_do_not_disturb_sensor`,\n        state_not: \"off\",\n      },\n    ],\n    show_last_changed: false,\n  });\n  const DND_IDX = sub_button.length - 1;\n  sub_button.push({\n    entity: `sensor.${phone_sensor_prefix}_ringer_mode`,\n    name: \"Ringer Mode\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    show_attribute: false,\n    attribute: \"options\",\n    show_name: false,\n  });\n  const RINGER_MODE_IDX = sub_button.length - 1;\n  sub_button.push({\n    entity: `sensor.${phone_sensor_prefix}_phone_state`,\n    name: \"Phone State\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    state_background: false,\n    visibility: [\n      {\n        condition: \"state\",\n        entity: `sensor.${phone_sensor_prefix}_phone_state`,\n        state_not: \"idle\",\n      },\n    ],\n  });\n  const PHONE_STATE_IDX = sub_button.length - 1;\n  sub_button.push({\n    entity: `binary_sensor.${phone_sensor_prefix}_android_auto`,\n    name: \"Android Auto\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    visibility: [\n      {\n        condition: \"state\",\n        entity: `binary_sensor.${phone_sensor_prefix}_android_auto`,\n        state_not: \"off\",\n      },\n    ],\n  });\n  const ANDROID_AUTO_IDX = sub_button.length - 1;\n  sub_button.push({\n    entity: `binary_sensor.${phone_sensor_prefix}_bluetooth_state`,\n    name: \"Bluetooth State\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n  });\n  const BT_IDX = sub_button.length - 1;\n\n  sub_button.push({\n    entity: ble_sensor,\n    name: \"BLE\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    show_name: true,\n    visibility: [\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(ble_sensor),\n      {\n        condition: \"state\",\n        entity: ble_sensor,\n        state: \"Transmitting\",\n      },\n    ],\n  });\n  const BLE_IDX = sub_button.length - 1;\n\n  sub_button.push({\n    entity: `sensor.${phone_sensor_prefix}_battery_level`,\n    name: \"Battery Level\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: true,\n  });\n  const BATTERY_IDX = sub_button.length - 1;\n\n  sub_button.push({\n    entity: remaining_charge_time_sensor,\n    name: \"Remaining Charge Time\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: true,\n    visibility: [\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(remaining_charge_time_sensor),\n      {\n        condition: \"state\",\n        entity: remaining_charge_time_sensor,\n        state_not: \"0\",\n      },\n    ],\n  });\n  const CHARGE_TIME_IDX = sub_button.length - 1;\n\n  sub_button.push({\n    entity: alarm_sensor,\n    name: \"Next Alarm\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    show_name: true,\n    visibility: [_helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(alarm_sensor)],\n  });\n  const NEXT_ALARM_IDX = sub_button.length - 1;\n\n  sub_button.push({\n    entity: alarm_sensor,\n    name: \"Next Alarm\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: false,\n    show_name: true,\n    visibility: [_helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(alarm_sensor)],\n  });\n  const NEXT_ALARM_HOURS_IDX = sub_button.length - 1;\n\n  // sub_button.push({\n  //   entity: alarm_sensor,\n  //   name: \"Next Alarm\",\n  //   show_background,\n  //   state_background,\n  //   show_icon: true,\n  //   show_state: false,\n  //   show_name: false,\n  //   show_attribute: true,\n  //   attribute: \"Package\",\n  //   visibility: [helpers.visibilityNotUnknownUnavailable(alarm_sensor)],\n  // });\n  // const NEXT_ALARM_PKG_IDX = sub_button.length - 1;\n\n  // Add steps sensor\n  sub_button.push({\n    entity: steps_sensor,\n    name: \"Daily Steps\",\n    show_background,\n    state_background,\n    show_icon: true,\n    show_state: true,\n    show_attribute: false,\n    show_name: false,\n  });\n  const STEPS_IDX = sub_button.length - 1;\n\n  // Get everything that is \"labelled\" with the person. I link to consider this as \"tagging\".\n  // This allows us to display entities that aren't directly linked to the person / tracker\n  const labelled = Object.values(entities).filter((x) => {\n    return (\n      x !== undefined &&\n      x.labels !== undefined &&\n      x.labels.includes(person.entity_id.split(\".\")[1])\n    );\n  });\n\n  labelled.forEach((entity) => {\n    sub_button.push({\n      entity: entity.entity_id,\n      name: entity.attributes.friendly_name,\n      show_background,\n      state_background,\n      show_icon: true,\n      show_state: true,\n      show_attribute: false,\n      show_name: false,\n    });\n  });\n\n  // How much space to put between each subbutton\n  const GAP = \"4px\";\n\n  // Create the styling\n  let styles = \"\";\n\n  // Move the subbuttons up a little so theres not as much space\n  styles += `\n    /* Move the subbuttons up a little so theres not as much space */\n    .bubble-wrapper {\n       height: 75%\n    }`;\n\n  // Make the Alarm subbutton take up full width\n  // styles += `.bubble-sub-button-${NEXT_ALARM_IDX + 1} { flex-basis: 70%; }`;\n  // styles += `.bubble-sub-button-${\n  //   NEXT_ALARM_HOURS_IDX + 1\n  // } { flex-basis: 25%; }`;\n\n  // Allow subbuttons to take up full width. I think? Can't remember why I did this but pretty sure its important. TODO: add proper documentation here.\n  // styles += `.card-content {width: 100%; margin: 0 !important;}\\n`;\n\n  // Hide the separator line\n  // styles += `.bubble-line { opacity: 0; }\\n`;\n\n  // Color the sleep confidence icon\n  styles += `.bubble-sub-button-${\n    SLEEP_CONFIDENCE_IDX + 1\n  } {color: ${sleep_confidence_color}}\\n`;\n\n  // Color the interactive icon\n  styles += `.bubble-sub-button-${\n    INTERACTIVE_IDX + 1\n  } {color: var(--state-active-color)}\\n`;\n  // styles += `.bubble-sub-button-2 {\\n  /* Do not disturb */\\n    color: var(--error-color) !important;\\n}\\n`;\n\n  // Add a class so we can break the flex-flow rows\n  styles += `.break {\n    flex-basis: 100%;\n    height: 0; \n    margin-top: -${GAP}; /* Cancels out one extra gap */\n    }\\n`;\n\n  // Change bluetooth icon to reflect connection state\n  styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n      if (hass.states['${bluetooth_connection_sensor}'].state > 0) {\n        if (this.config.sub_button[${BT_IDX}].icon !== 'mdi:bluetooth-connect') {\n          this.config.sub_button[${BT_IDX}].icon = 'mdi:bluetooth-connect';\n        }\n    } else { delete this.config.sub_button[${BT_IDX}].icon }\n      `);\n\n  // Update the Ringer Volume Level to a Percentage\n  styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n    // Update Phone Ringer Volume to a percentage\n    const target = card.querySelector('.bubble-sub-button-${\n      PHONE_STATE_IDX + 1\n    } .bubble-sub-button-name-container');\n    if (hass.states['${ringer_mode_sensor}'].state === 'normal') {\n      const maxRingerVolume = 16\n      const ringerVolume = hass.states['${volume_level_ringer_sensor}'].state;\n      const volumePercentage = Math.round((ringerVolume / maxRingerVolume) * 100);\n      target.innerText = \\`\\${volumePercentage}%\\`;\n    } \n    else { target.innerText = '' }`);\n\n  // Update the Ringer Mode Icon\n  styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n      const phoneState = hass.states['${phone_state_sensor}']?.state;  \n      if (phoneState === 'idle') {\n          this.config.sub_button[${PHONE_STATE_IDX}].icon = \"mdi:phone-hangup\";\n      }\n      else if (phoneState === 'ringing') {\n          this.config.sub_button[${PHONE_STATE_IDX}].icon = \"mdi:phone-ring\";\n      }\n      else if (phoneState === 'offhook') {\n          this.config.sub_button[${PHONE_STATE_IDX}].icon = \"mdi:phone-in-talk\";\n      }  \n      else  {\n          delete this.config.sub_button[${PHONE_STATE_IDX}].icon;\n      }\n      `);\n\n  // Format the Next Alarm time\n  styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n    const alarmEntity = hass.states['${alarm_sensor}'];\n    const alarmTimeMs = alarmEntity?.attributes?.['Time in Milliseconds'];\n    if (alarmTimeMs === undefined) { return; }\n    ${getOrdinalSuffix.toString()}\n    ${formatEpoch.toString()}\n    const alarm_formatted_data = ${formatEpoch.name}(alarmTimeMs)\n    this.config.sub_button[${NEXT_ALARM_IDX}].name=alarm_formatted_data.date;\n    this.config.sub_button[${NEXT_ALARM_HOURS_IDX}].name=alarm_formatted_data.hours;\n\n    const alarmPkg = alarmEntity.attributes.Package.split('.').at(-1).toLowerCase().replace(/package$/, \"\")\n\n    if (alarmPkg.startsWith(\"clock\") || alarmPkg.endsWith(\"clock\")){}\n    else {\n      this.config.sub_button[${NEXT_ALARM_IDX}].name += ' | ' + alarmPkg.charAt(0).toUpperCase() + alarmPkg.slice(1);\n    }`);\n\n  // Add a breaks before the next alarm subbutton\n  styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n    const container = card.querySelector(\".bubble-sub-button-container\");\n    if (!container) return;\n\n    const targetElement = container.querySelector('.bubble-sub-button-${\n      NEXT_ALARM_IDX + 1\n    }');\n    if (!targetElement) return;\n\n    // Check if a break element already exists before the target\n    if (targetElement.previousElementSibling?.classList.contains(\"break\")) return;\n\n    // Create the break element\n    const breakEl = document.createElement(\"div\");\n    breakEl.classList.add(\"break\");\n\n    // Insert before the target element\n    container.insertBefore(breakEl, targetElement);\n  `);\n\n  // Add a breaks before the steps subbutton\n  styles += _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n    const container = card.querySelector(\".bubble-sub-button-container\");\n    if (!container) return;\n\n    const targetElement = container.querySelector('.bubble-sub-button-${\n      STEPS_IDX + 1\n    }');\n    if (!targetElement) return;\n\n    // Check if a break element already exists before the target\n    if (targetElement.previousElementSibling?.classList.contains(\"break\")) return;\n\n    // Create the break element\n    const breakEl = document.createElement(\"div\");\n    breakEl.classList.add(\"break\");\n\n    // Insert before the target element\n    container.insertBefore(breakEl, targetElement);\n  `);\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    button_type: \"name\",\n    show_icon: false,\n    show_state: false,\n    show_name: false,\n    sub_button,\n    card_layout: \"large\",\n    styles,\n    modules: [..._helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES, \"bubble_chips\"],\n    grid_options: {\n      columns: \"full\",\n      rows: \"auto\",\n    },\n    bubble_chips: {\n      gap: 3,\n      \"justify-content\": \"flex-right\",\n    },\n  };\n}\n\nfunction alarmCard(person) {\n  // TODO: be smarter about what device tracker we consider their phone\n  // For now we just assume it exists and that its the first device tracker listed\n  // We should instead parse them all, looking for one that is from the right platform/integration\n  // Then maybe return multiple cards for all phones we find\n  const phone_entity_id = person.attributes.device_trackers[0];\n\n  // TODO: Make all the subbuttons first test that the entity exists\n  // When we do, we must also account for that in the styles\n  const phone_sensor_prefix = phone_entity_id.split(\".\")[1];\n\n  // Create a really long string that will induce scrolling\n  const SCROLLING_TEXT_TO_REPLACE = \"SCROLLING\";\n\n  const styles =\n    `\n    .bubble-name-container {\n    margin-right: 0px !important;\n  }\n    ` +\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n    function capitalizeFirst(str) {\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n\n    // Extract the package that set the alarm\n    const packageElement = card.querySelector('.bubble-state');\n    packageElement.textContent = packageElement.textContent.split('.').at(-1) // Get the last part of the package as thats typically the useful part\n    if (packageElement.textContent.startsWith(\"clock\") || packageElement.textContent.endsWith(\"clock\")) {\n      // If its just the clock, then blank it out because we can reasonably assume that\n      packageElement.textContent = \"\";\n    }\n    // If we didn't blank it then make it capitalized\n    packageElement.textContent = capitalizeFirst(packageElement.textContent);\n\n\n    const alarmEntity = hass.states['sensor.${phone_sensor_prefix}_next_alarm'];\n    const alarmTimeMs = alarmEntity?.attributes?.['Time in Milliseconds'];\n\n    if (alarmTimeMs) {\n      const alarmDate = new Date(alarmTimeMs); // Convert milliseconds to Date object\n\n      try {\n        // Format as a time string using toLocaleTimeString\n        const formattedTime = alarmDate.toLocaleTimeString('en-US', {\n            hour: 'numeric',\n            minute: '2-digit',\n        });\n\n        //const bubbleNameContainer = card.querySelector('.bubble-name.name .scrolling-container span');\n        const bubbleNameContainer = card.querySelector('.bubble-name.name');\n        if (bubbleNameContainer) {\n          // const bubbleNameContainerInnerHTML = bubbleNameContainer.innerHTML.replace(/${SCROLLING_TEXT_TO_REPLACE}/g, formattedTime);\n          // if (bubbleNameContainer.innerHTML !== bubbleNameContainerInnerHTML) { bubbleNameContainer.innerHTML = bubbleNameContainerInnerHTML }\n          bubbleNameContainer.textContent = formattedTime;\n        }\n\n        // const bubbleNameContainer = card.querySelector('.bubble-name-container');\n        // bubbleNameContainer.innerText = formattedTime;\n\n      } catch (error) { console.error(\"Error shortening alarm time:\", error)}\n\n      try {\n        const timeETAElement = card.querySelector('.bubble-sub-button-1 .bubble-sub-button-name-container');\n\n        if (timeETAElement && alarmTimeMs) {\n          const currentDate = new Date();\n\n          // Calculate the difference in hours\n          const timeDiffMs = alarmDate - currentDate; // Difference in milliseconds\n          const hoursLeft = Math.max((timeDiffMs / (1000 * 60 * 60)), 0); // Convert ms to hours with decimals\n          const formattedHoursLeft = hoursLeft.toFixed(1) % 1 === 0 ? hoursLeft.toFixed(0) : hoursLeft.toFixed(1);\n          const hourLabel = hoursLeft === 1 ? \"hour\" : \"hours\";\n\n          // Make a newline if the screen is too narrow. Otherwise just a space.\n          const hoursPrefixSeparator = window.innerWidth <= 900 ? '\\\\n' : ' ';\n\n          // Display the date, time, and \"in X hours\" message\n          // timeETAElement.innerText = \\`In about\\${hoursPrefixSeparator}\\${formattedHoursLeft} \\${hourLabel}\\`;\n          timeETAElement.innerText = \\`\\${formattedHoursLeft} \\${hourLabel}\\`;\n          //timeETAElement.classList.add('center-content'); // Add centering class\n\n        } else if (timeETAElement) {\n          timeETAElement.innerText = \"No alarm set\";\n        }\n      } catch (error) {\n        console.error(\"Error updating alarm time:\", error);\n      }\n  }\n  `);\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    button_type: \"state\",\n    entity: `sensor.${phone_sensor_prefix}_next_alarm`,\n    show_name: true,\n    name: SCROLLING_TEXT_TO_REPLACE,\n    show_attribute: true,\n    attribute: \"Package\",\n    show_last_changed: false,\n    scrolling_effect: false,\n    show_state: false,\n    sub_button: [\n      {\n        name: \"In X Time\",\n        entity: `sensor.${phone_sensor_prefix}_next_alarm`,\n        show_name: false,\n        show_state: true,\n        show_last_changed: false,\n        show_attribute: false,\n        state_background: false,\n        show_background: false,\n        show_icon: false,\n      },\n    ],\n    card_layout: \"large\",\n    visibility: [\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(\n        `sensor.${phone_sensor_prefix}_next_alarm`\n      ),\n    ],\n    styles,\n    columns: 2.25,\n  };\n}\n\nfunction alarmCard2(person) {\n  // TODO: be smarter about what device tracker we consider their phone\n  // For now we just assume it exists and that its the first device tracker listed\n  // We should instead parse them all, looking for one that is from the right platform/integration\n  // Then maybe return multiple cards for all phones we find\n  const phone_entity_id = person.attributes.device_trackers[0];\n\n  // TODO: Make all the subbuttons first test that the entity exists\n  // When we do, we must also account for that in the styles\n  const phone_sensor_prefix = phone_entity_id.split(\".\")[1];\n\n  const justify_content = \"space-between\";\n  const icon_px = 46;\n  const styles =\n    `\n    .card-content {\n      width: 100%;\n      margin: 0 !important;\n    }\n    .bubble-sub-button {\n      height: ${icon_px}px !important;\n      width: ${icon_px}px !important;\n    }\n\n    .bubble-sub-button-container {\n      display: flex !important;\n      width: 100%;\n      justify-content: ${justify_content} !important;\n    }\n\n    .bubble-sub-button-icon {\n      --mdc-icon-size: inherit !important;\n    }\n\n    .bubble-name-container {\n      margin-right: 0 !important;\n    }\n` +\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(`\n    function capitalizeFirst(str) {\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n\n    // Extract the package that set the alarm\n    const packageElement = card.querySelector('.bubble-state');\n    packageElement.textContent = packageElement.textContent.split('.').at(-1) // Get the last part of the package as thats typically the useful part\n    if (packageElement.textContent.startsWith(\"clock\") || packageElement.textContent.endsWith(\"clock\")) {\n      // If its just the clock, then blank it out because we can reasonably assume that\n      packageElement.textContent = \"\";\n    }\n    // If we didn't blank it then make it capitalized\n    packageElement.textContent = capitalizeFirst(packageElement.textContent);\n\n\n    const alarmEntity = hass.states['sensor.${phone_sensor_prefix}_next_alarm'];\n    const alarmTimeMs = alarmEntity?.attributes?.['Time in Milliseconds'];\n\n    if (alarmTimeMs) {\n      const alarmDate = new Date(alarmTimeMs); // Convert milliseconds to Date object\n\n      try {\n        // Format as a time string using toLocaleTimeString\n        const formattedTime = alarmDate.toLocaleTimeString('en-US', {\n            hour: 'numeric',\n            minute: '2-digit',\n        });\n\n      } catch (error) { console.error(\"Error shortening alarm time:\", error)}\n\n      try {\n        const timeETAElement = card.querySelector('.bubble-sub-button-1 .bubble-sub-button-name-container');\n\n        if (timeETAElement && alarmTimeMs) {\n          const currentDate = new Date();\n\n          // Calculate the difference in hours\n          const timeDiffMs = alarmDate - currentDate; // Difference in milliseconds\n          const hoursLeft = Math.max((timeDiffMs / (1000 * 60 * 60)), 0); // Convert ms to hours with decimals\n          const formattedHoursLeft = hoursLeft.toFixed(1) % 1 === 0 ? hoursLeft.toFixed(0) : hoursLeft.toFixed(1);\n          const hourLabel = hoursLeft === 1 ? \"hour\" : \"hours\";\n\n          // Make a newline if the screen is too narrow. Otherwise just a space.\n          const hoursPrefixSeparator = window.innerWidth <= 900 ? '\\\\n' : ' ';\n\n          // Display the date, time, and \"in X hours\" message\n          // timeETAElement.innerText = \\`In about\\${hoursPrefixSeparator}\\${formattedHoursLeft} \\${hourLabel}\\`;\n          timeETAElement.innerText = \\`\\${formattedHoursLeft} \\${hourLabel}\\`;\n          //timeETAElement.classList.add('center-content'); // Add centering class\n\n        } else if (timeETAElement) {\n          timeETAElement.innerText = \"No alarm set\";\n        }\n      } catch (error) {\n        console.error(\"Error updating alarm time:\", error);\n      }\n  }\n  `);\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"separator\",\n    button_type: \"state\",\n    show_name: false,\n    name: \"\",\n    show_attribute: false,\n    show_last_changed: false,\n    scrolling_effect: false,\n    show_state: false,\n    sub_button: [\n      {\n        name: \"In X Time\",\n        entity: `sensor.${phone_sensor_prefix}_next_alarm`,\n        show_name: false,\n        show_state: true,\n        show_last_changed: false,\n        show_attribute: false,\n        state_background: false,\n        show_background: false,\n        show_icon: false,\n      },\n    ],\n    card_layout: \"large\",\n    visibility: [\n      _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(\n        `sensor.${phone_sensor_prefix}_next_alarm`\n      ),\n    ],\n    styles,\n    grid_options: {\n      columns: 2.25,\n    },\n    modules: _helpers_js__WEBPACK_IMPORTED_MODULE_0__.BUBBLE_MODULES,\n  };\n}\n\n// Functions to help manipulate Alarm Icon via Styles\n// We will call the `toString()` method on these functions to get the string to put in the styles\n/**\n * Returns the day of month with its ordinal suffix (e.g., 1st, 2nd, 3rd, 4th).\n * @param {number} n - The day of the month.\n * @returns {string} The day with its ordinal suffix.\n */\nfunction getOrdinalSuffix(n) {\n  if (n % 100 >= 11 && n % 100 <= 13) {\n    return n + \"th\";\n  }\n  switch (n % 10) {\n    case 1:\n      return n + \"st\";\n    case 2:\n      return n + \"nd\";\n    case 3:\n      return n + \"rd\";\n    default:\n      return n + \"th\";\n  }\n}\n\n/**\n * Converts an epoch timestamp to a human-friendly format.\n *\n * Returns an object containing:\n * - date: The date information (day of the week, time), e.g., \"Today @ 8:30 AM\"\n * - hours: The future time difference in decimal hours, e.g., \"5.2 hours\"\n * - combined: Both pieces separated by \" | \"\n *\n * If the date is today or tomorrow, it prefixes with \"Today @\" or \"Tomorrow @\" respectively.\n * @param {number} epoch - Epoch time in seconds or milliseconds.\n * @returns {object} Object with keys: date, hours, combined.\n */\nfunction formatEpoch(epoch) {\n  // Convert to milliseconds if necessary.\n  if (epoch.toString().length === 10) {\n    epoch *= 1000;\n  }\n  const alarmDate = new Date(epoch);\n\n  // Get current time and today's/tomorrow's dates.\n  const now = new Date();\n  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n  const tomorrow = new Date(\n    now.getFullYear(),\n    now.getMonth(),\n    now.getDate() + 1\n  );\n\n  // Check if alarmDate is today or tomorrow.\n  const isToday =\n    alarmDate.getFullYear() === today.getFullYear() &&\n    alarmDate.getMonth() === today.getMonth() &&\n    alarmDate.getDate() === today.getDate();\n  const isTomorrow =\n    alarmDate.getFullYear() === tomorrow.getFullYear() &&\n    alarmDate.getMonth() === tomorrow.getMonth() &&\n    alarmDate.getDate() === tomorrow.getDate();\n\n  // Format time component.\n  const formattedTime = alarmDate.toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n  });\n\n  // Build date string.\n  let dateString;\n  if (isToday) {\n    dateString = `Today @ ${formattedTime}`;\n  } else if (isTomorrow) {\n    dateString = `Tomorrow @ ${formattedTime}`;\n  } else {\n    const weekday = alarmDate.toLocaleDateString(\"en-US\", { weekday: \"long\" });\n    dateString = `${weekday} @ ${formattedTime}`;\n  }\n\n  // Calculate how far into the future the alarm is in decimal hours.\n  let diffMs = Math.max(0, alarmDate - now);\n  const diffHoursDecimal = diffMs / (1000 * 60 * 60);\n  // Check if the value is effectively a whole number.\n  const isWhole =\n    Math.abs(diffHoursDecimal - Math.round(diffHoursDecimal)) < 0.001;\n  const hoursStr = isWhole\n    ? Math.round(diffHoursDecimal).toString()\n    : diffHoursDecimal.toFixed(1);\n  const hourLabel = parseFloat(hoursStr) === 1 ? \" hour\" : \" hours\";\n  const futureString = hoursStr + hourLabel;\n\n  const combined = `${dateString} | ${futureString}`;\n\n  return { date: dateString, hours: futureString, combined };\n}\n\ncustomElements.define(\"ll-strategy-view-magic-people\", PeopleView);\n\n\n//# sourceURL=webpack://magic-dashboard-strategy/./src/views/people.js?");

/***/ }),

/***/ "./src/views/temperature.js":
/*!**********************************!*\
  !*** ./src/views/temperature.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/views/helpers.js\");\n\n\nconst TITLE = \"Individual Area Thermometers\";\n\nfunction getEntity(entities, entity_id) {\n  return entities.filter((x) => x.entity_id == entity_id);\n}\n\nfunction entityAttributeIs(entity, attribute, value) {\n  if (\"attributes\" in entity && attribute in entity.attributes) {\n    return entity.attributes[attribute] === value;\n  } else {\n    return false;\n  }\n}\n\nfunction entityIsClass(entity, deviceClass) {\n  return entityAttributeIs(entity, \"device_class\", deviceClass);\n}\n\nclass TemperatureView {\n  static async generate(config, hass) {\n    const { mergedEntityMetadata } = config;\n\n    const sections = [];\n    const max_columns = 2;\n\n    const thermometers = Object.values(mergedEntityMetadata)\n      .filter((entity) => entityIsClass(entity, \"temperature\")) // Filter to temperature class\n      .filter((entity) => entity.area_id !== null) // Filter to those with an area to filter out things like Google Fit Body temperature and weather\n      .filter((entity) => !entityAttributeIs(entity, \"restored\", true)) // Filter to non-restored\n      .filter((entity) => [\"living_room\", \"office\"].includes(entity.area_id)) // Temp filter to just the areas I want. TODO: remove temp filter\n      .filter((entity) => entity.platform !== \"magic_areas\"); // Temp filter to get rid of magic areas. TODO: make one of just the magic areas\n\n    // const graph = {\n    //   type: \"history-graph\",\n    //   entities: thermometers.map((x) => ({ entity: x.entity_id })),\n    // };\n\n    const graph = {\n      type: \"custom:plotly-graph\",\n      title: TITLE,\n      entities: thermometers.map((x) => ({ entity: x.entity_id })),\n      hours_to_show: 24,\n      refresh_interval: 10,\n      layout: {\n        xaxis: {\n          tickformat: \"%I:%M %p\", // 12-hour format with AM/PM - TODO: make it use browser settings\n          rangeselector: {\n            // see examples: https://plotly.com/javascript/range-slider/\n            // see API: https://plotly.com/javascript/reference/layout/xaxis/#layout-xaxis-rangeselector\n            x: 0,\n            y: -0.2, // Move it to the bottom so we won't cover up the labels\n            buttons: [\n              {\n                count: 1,\n                step: \"minute\",\n              },\n              {\n                count: 30,\n                step: \"minute\",\n              },\n              {\n                count: 1,\n                step: \"hour\",\n              },\n              {\n                count: 12,\n                step: \"hour\",\n              },\n              {\n                count: 1,\n                step: \"day\",\n              },\n              {\n                count: 7,\n                step: \"day\",\n              },\n            ],\n          },\n        },\n      },\n    };\n\n    sections.push(_helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid([graph], max_columns));\n\n    result = {\n      type: \"panel\",\n      title: TITLE,\n      cards: [graph],\n      badges: [_helpers_js__WEBPACK_IMPORTED_MODULE_0__.alertBadge()],\n    }\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.AddCardMod(result);\n    return result;\n  }\n}\n\ncustomElements.define(\"ll-strategy-view-magic-temperature\", TemperatureView);\n\n\n//# sourceURL=webpack://magic-dashboard-strategy/./src/views/temperature.js?");

/***/ }),

/***/ "./src/views/weather.js":
/*!******************************!*\
  !*** ./src/views/weather.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/views/helpers.js\");\n\n\nfunction header() {\n  const styles = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.wrapInBubbleCardStyleIIFE(\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.bubbleStyleConditional2Row(\"window.innerWidth < 768\")\n  );\n\n  // Show background on subbuttons\n  const show_background = true;\n\n  return {\n    type: \"custom:bubble-card\",\n    card_type: \"button\",\n    button_type: \"state\",\n    entity: \"sensor.magic_areas_aggregates_interior_aggregate_temperature\",\n    name: \"Indoors\",\n    sub_button: [\n      {\n        entity:\n          \"sensor.magic_areas_aggregates_interior_aggregate_carbon_dioxide\",\n        show_name: false,\n        show_icon: true,\n        state_background: false,\n        show_background,\n        show_attribute: false,\n        attribute: \"friendly_name\",\n        show_last_changed: false,\n        show_state: true,\n        name: \"CO₂\",\n        visibility: [\n          _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(\n            \"sensor.magic_areas_aggregates_interior_aggregate_carbon_dioxide\"\n          ),\n        ],\n      },\n      {\n        entity: \"sensor.magic_areas_aggregates_interior_aggregate_humidity\",\n        show_name: false,\n        show_icon: true,\n        state_background: false,\n        show_background,\n        show_attribute: false,\n        attribute: \"friendly_name\",\n        show_last_changed: false,\n        show_state: true,\n        name: \"Humidity\",\n        visibility: [\n          _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(\n            \"sensor.magic_areas_aggregates_interior_aggregate_humidity\"\n          ),\n        ],\n      },\n      {\n        entity:\n          \"sensor.magic_areas_aggregates_interior_aggregate_volatile_organic_compounds_parts\",\n        show_name: false,\n        show_icon: true,\n        state_background: false,\n        show_background,\n        show_attribute: false,\n        attribute: \"friendly_name\",\n        show_last_changed: false,\n        show_state: true,\n        name: \"VOC\",\n        visibility: [\n          {\n            condition: \"screen\",\n            media_query: \"(min-width: 768px)\",\n          },\n          _helpers_js__WEBPACK_IMPORTED_MODULE_0__.visibilityNotUnknownUnavailable(\n            \"sensor.magic_areas_aggregates_interior_aggregate_volatile_organic_compounds_parts\"\n          ),\n        ],\n      },\n    ],\n    card_layout: \"large\",\n    grid_options: {\n      columns: \"full\",\n    },\n    styles,\n  };\n}\n\nfunction clock(entity_id) {\n  return {\n    type: \"custom:clock-weather-card\",\n    entity: entity_id,\n    show_humidity: true,\n    forecast_rows: 7,\n    apparent_sensor: \"sensor.home_apparent_temperature\",\n  };\n}\n\nfunction hourly(entity_id) {\n  return {\n    type: \"custom:clock-weather-card\",\n    entity: entity_id,\n    show_humidity: false,\n    hide_today_section: true,\n    hourly_forecast: true,\n    forecast_rows: 24,\n  };\n}\n\nclass WeatherView {\n  static async generate(config, hass) {\n    const { devices, entities, weather_entity_id } = config;\n    const max_columns = 2;\n\n    const weather_entity_ida = \"weather.home\";\n\n    const sections = [];\n\n    sections.push(_helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(header(), max_columns));\n    sections.push(_helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(clock(weather_entity_ida)));\n    sections.push(_helpers_js__WEBPACK_IMPORTED_MODULE_0__.newGrid(hourly(weather_entity_ida)));\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.AddCardMod(sections)\n    return {\n      type: \"sections\",\n      max_columns: max_columns,\n      sections,\n      badges: [_helpers_js__WEBPACK_IMPORTED_MODULE_0__.alertBadge()],\n    };\n  }\n}\n\ncustomElements.define(\"ll-strategy-view-magic-weather\", WeatherView);\n\n\n//# sourceURL=webpack://magic-dashboard-strategy/./src/views/weather.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./src/magic-dashboard-strategy.js");
/******/ 	__webpack_require__("./src/views/weather.js");
/******/ 	__webpack_require__("./src/views/temperature.js");
/******/ 	__webpack_require__("./src/views/people.js");
/******/ 	__webpack_require__("./src/views/helpers.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/views/area.js");
/******/ 	
/******/ })()
;